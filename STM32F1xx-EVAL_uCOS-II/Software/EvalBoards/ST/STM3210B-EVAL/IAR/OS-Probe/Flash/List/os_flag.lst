###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.3.8024/W32 for ARM        27/Feb/2018  22:18:57
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\uCOS-II\Source\os_flag.c
#    Command line =  
#        "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\uCOS-II\Source\os_flag.c"
#        -lCN "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\"
#        -o "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\CPU\ST\STM32\inc\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-CPU\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-LCD\Source\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-LIB\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uCOS-II\Source\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\"
#        -Ol --use_c++_inline
#    List file    =  
#        F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\os_flag.lst
#    Object file  =  
#        F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\os_flag.o
#
###############################################################################

F:\Study\uCOS\UCOS II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\uCOS-II\Source\os_flag.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                         EVENT FLAG  MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_FLAG.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.86
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
     29          /*
     30          *********************************************************************************************************
     31          *                                            LOCAL PROTOTYPES
     32          *********************************************************************************************************
     33          */
     34          
     35          static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout);
     36          static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy);
     37          
     38          /*$PAGE*/
     39          /*
     40          *********************************************************************************************************
     41          *                              CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
     42          *
     43          * Description: This function is called to check the status of a combination of bits to be set or cleared
     44          *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
     45          *              bits to be set/cleared.
     46          *
     47          *              This call does not block if the desired flags are not present.
     48          *
     49          * Arguments  : pgrp          is a pointer to the desired event flag group.
     50          *
     51          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
     52          *                            The bits you want are specified by setting the corresponding bits in
     53          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
     54          *                            'flags' would contain 0x03.
     55          *
     56          *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
     57          *                            to be set/cleared.
     58          *                            You can specify the following argument:
     59          *
     60          *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
     61          *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
     62          *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
     63          *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
     64          *
     65          *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
     66          *                                  the call.  Example, to wait for any flag in a group AND then clear
     67          *                                  the flags that are present, set 'wait_type' to:
     68          *
     69          *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
     70          *
     71          *              perr          is a pointer to an error code and can be:
     72          *                            OS_ERR_NONE               No error
     73          *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
     74          *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
     75          *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
     76          *                                                      group handle.
     77          *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
     78          *                                                      available.
     79          *
     80          * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
     81          *              occurred.
     82          *
     83          * Called from: Task or ISR
     84          *
     85          * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
     86          *                 function NOW returns the flags that were ready INSTEAD of the current state of the
     87          *                 event flags.
     88          *********************************************************************************************************
     89          */
     90          
     91          #if OS_FLAG_ACCEPT_EN > 0

   \                                 In section .text, align 2, keep-with-next
     92          OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
     93          {
   \                     OSFlagAccept: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001C             MOVS     R4,R3
     94              OS_FLAGS      flags_rdy;
     95              INT8U         result;
     96              BOOLEAN       consume;
     97          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
     98              OS_CPU_SR     cpu_sr = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
     99          #endif
    100          
    101          
    102          
    103          #if OS_ARG_CHK_EN > 0
    104              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    105                  return ((OS_FLAGS)0);
    106              }
    107              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    108                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    109                  return ((OS_FLAGS)0);
    110              }
    111          #endif
    112              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
   \   0000000E   0x7828             LDRB     R0,[R5, #+0]
   \   00000010   0x2805             CMP      R0,#+5
   \   00000012   0xD003             BEQ.N    ??OSFlagAccept_0
    113                  *perr = OS_ERR_EVENT_TYPE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7020             STRB     R0,[R4, #+0]
    114                  return ((OS_FLAGS)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE076             B.N      ??OSFlagAccept_1
    115              }
    116              result = (INT8U)(wait_type & OS_FLAG_CONSUME);
   \                     ??OSFlagAccept_0: (+1)
   \   0000001C   0xF018 0x0080      ANDS     R0,R8,#0x80
    117              if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD003             BEQ.N    ??OSFlagAccept_2
    118                  wait_type &= ~OS_FLAG_CONSUME;
   \   00000026   0xF018 0x087F      ANDS     R8,R8,#0x7F
    119                  consume    = OS_TRUE;
   \   0000002A   0x2701             MOVS     R7,#+1
   \   0000002C   0xE000             B.N      ??OSFlagAccept_3
    120              } else {
    121                  consume    = OS_FALSE;
   \                     ??OSFlagAccept_2: (+1)
   \   0000002E   0x2700             MOVS     R7,#+0
    122              }
    123          /*$PAGE*/
    124              *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
   \                     ??OSFlagAccept_3: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x7020             STRB     R0,[R4, #+0]
    125              OS_ENTER_CRITICAL();
   \   00000034   0x.... 0x....      BL       OS_CPU_SR_Save
    126              switch (wait_type) {
   \   00000038   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000040   0xD031             BEQ.N    ??OSFlagAccept_4
   \   00000042   0xF1B8 0x0F02      CMP      R8,#+2
   \   00000046   0xD004             BEQ.N    ??OSFlagAccept_5
   \   00000048   0xD342             BCC.N    ??OSFlagAccept_6
   \   0000004A   0xF1B8 0x0F03      CMP      R8,#+3
   \   0000004E   0xD015             BEQ.N    ??OSFlagAccept_7
   \   00000050   0xE053             B.N      ??OSFlagAccept_8
    127                  case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
    128                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
   \                     ??OSFlagAccept_5: (+1)
   \   00000052   0x8929             LDRH     R1,[R5, #+8]
   \   00000054   0xEA16 0x0801      ANDS     R8,R6,R1
    129                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   00000058   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000005C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005E   0x45B0             CMP      R8,R6
   \   00000060   0xD107             BNE.N    ??OSFlagAccept_9
    130                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   00000062   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000064   0x2F01             CMP      R7,#+1
   \   00000066   0xD106             BNE.N    ??OSFlagAccept_10
    131                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
   \   00000068   0x8929             LDRH     R1,[R5, #+8]
   \   0000006A   0xEA31 0x0108      BICS     R1,R1,R8
   \   0000006E   0x8129             STRH     R1,[R5, #+8]
   \   00000070   0xE001             B.N      ??OSFlagAccept_10
    132                           }
    133                       } else {
    134                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_9: (+1)
   \   00000072   0x2170             MOVS     R1,#+112
   \   00000074   0x7021             STRB     R1,[R4, #+0]
    135                       }
    136                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_10: (+1)
   \   00000076   0x.... 0x....      BL       OS_CPU_SR_Restore
    137                       break;
   \   0000007A   0xE044             B.N      ??OSFlagAccept_11
    138          
    139                  case OS_FLAG_WAIT_SET_ANY:
    140                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
   \                     ??OSFlagAccept_7: (+1)
   \   0000007C   0x8929             LDRH     R1,[R5, #+8]
   \   0000007E   0xEA16 0x0801      ANDS     R8,R6,R1
    141                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
   \   00000082   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000086   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000008A   0xD007             BEQ.N    ??OSFlagAccept_12
    142                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   0000008C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008E   0x2F01             CMP      R7,#+1
   \   00000090   0xD106             BNE.N    ??OSFlagAccept_13
    143                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
   \   00000092   0x8929             LDRH     R1,[R5, #+8]
   \   00000094   0xEA31 0x0108      BICS     R1,R1,R8
   \   00000098   0x8129             STRH     R1,[R5, #+8]
   \   0000009A   0xE001             B.N      ??OSFlagAccept_13
    144                           }
    145                       } else {
    146                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_12: (+1)
   \   0000009C   0x2170             MOVS     R1,#+112
   \   0000009E   0x7021             STRB     R1,[R4, #+0]
    147                       }
    148                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_13: (+1)
   \   000000A0   0x.... 0x....      BL       OS_CPU_SR_Restore
    149                       break;
   \   000000A4   0xE02F             B.N      ??OSFlagAccept_11
    150          
    151          #if OS_FLAG_WAIT_CLR_EN > 0
    152                  case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
    153                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
   \                     ??OSFlagAccept_4: (+1)
   \   000000A6   0x8929             LDRH     R1,[R5, #+8]
   \   000000A8   0xEA36 0x0801      BICS     R8,R6,R1
    154                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   000000AC   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000B0   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B2   0x45B0             CMP      R8,R6
   \   000000B4   0xD107             BNE.N    ??OSFlagAccept_14
    155                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   000000B6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B8   0x2F01             CMP      R7,#+1
   \   000000BA   0xD106             BNE.N    ??OSFlagAccept_15
    156                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
   \   000000BC   0x8929             LDRH     R1,[R5, #+8]
   \   000000BE   0xEA58 0x0101      ORRS     R1,R8,R1
   \   000000C2   0x8129             STRH     R1,[R5, #+8]
   \   000000C4   0xE001             B.N      ??OSFlagAccept_15
    157                           }
    158                       } else {
    159                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_14: (+1)
   \   000000C6   0x2170             MOVS     R1,#+112
   \   000000C8   0x7021             STRB     R1,[R4, #+0]
    160                       }
    161                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_15: (+1)
   \   000000CA   0x.... 0x....      BL       OS_CPU_SR_Restore
    162                       break;
   \   000000CE   0xE01A             B.N      ??OSFlagAccept_11
    163          
    164                  case OS_FLAG_WAIT_CLR_ANY:
    165                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
   \                     ??OSFlagAccept_6: (+1)
   \   000000D0   0x8929             LDRH     R1,[R5, #+8]
   \   000000D2   0xEA36 0x0801      BICS     R8,R6,R1
    166                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
   \   000000D6   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000DA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000DE   0xD007             BEQ.N    ??OSFlagAccept_16
    167                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   000000E0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E2   0x2F01             CMP      R7,#+1
   \   000000E4   0xD106             BNE.N    ??OSFlagAccept_17
    168                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
   \   000000E6   0x8929             LDRH     R1,[R5, #+8]
   \   000000E8   0xEA58 0x0101      ORRS     R1,R8,R1
   \   000000EC   0x8129             STRH     R1,[R5, #+8]
   \   000000EE   0xE001             B.N      ??OSFlagAccept_17
    169                           }
    170                       } else {
    171                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_16: (+1)
   \   000000F0   0x2170             MOVS     R1,#+112
   \   000000F2   0x7021             STRB     R1,[R4, #+0]
    172                       }
    173                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_17: (+1)
   \   000000F4   0x.... 0x....      BL       OS_CPU_SR_Restore
    174                       break;
   \   000000F8   0xE005             B.N      ??OSFlagAccept_11
    175          #endif
    176          
    177                  default:
    178                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_8: (+1)
   \   000000FA   0x.... 0x....      BL       OS_CPU_SR_Restore
    179                       flags_rdy = (OS_FLAGS)0;
   \   000000FE   0xF05F 0x0800      MOVS     R8,#+0
    180                       *perr     = OS_ERR_FLAG_WAIT_TYPE;
   \   00000102   0x206F             MOVS     R0,#+111
   \   00000104   0x7020             STRB     R0,[R4, #+0]
    181                       break;
    182              }
    183              return (flags_rdy);
   \                     ??OSFlagAccept_11: (+1)
   \   00000106   0x4640             MOV      R0,R8
   \   00000108   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagAccept_1: (+1)
   \   0000010A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    184          }
    185          #endif
    186          
    187          /*$PAGE*/
    188          /*
    189          *********************************************************************************************************
    190          *                                           CREATE AN EVENT FLAG
    191          *
    192          * Description: This function is called to create an event flag group.
    193          *
    194          * Arguments  : flags         Contains the initial value to store in the event flag group.
    195          *
    196          *              perr          is a pointer to an error code which will be returned to your application:
    197          *                               OS_ERR_NONE               if the call was successful.
    198          *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
    199          *                                                         ISR.
    200          *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
    201          *
    202          * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
    203          *
    204          * Called from: Task ONLY
    205          *********************************************************************************************************
    206          */
    207          

   \                                 In section .text, align 2, keep-with-next
    208          OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
    209          {
   \                     OSFlagCreate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    210              OS_FLAG_GRP *pgrp;
    211          #if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    212              OS_CPU_SR    cpu_sr = 0;
   \   00000006   0x2000             MOVS     R0,#+0
    213          #endif
    214          
    215          
    216          
    217          #if OS_ARG_CHK_EN > 0
    218              if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
    219                  return ((OS_FLAG_GRP *)0);
    220              }
    221          #endif
    222              if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSFlagCreate_0
    223                  *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
   \   00000012   0x2010             MOVS     R0,#+16
   \   00000014   0x7020             STRB     R0,[R4, #+0]
    224                  return ((OS_FLAG_GRP *)0);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE020             B.N      ??OSFlagCreate_1
    225              }
    226              OS_ENTER_CRITICAL();
   \                     ??OSFlagCreate_0: (+1)
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
    227              pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \   00000022   0x680E             LDR      R6,[R1, #+0]
    228              if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD014             BEQ.N    ??OSFlagCreate_2
    229                                                              /* Adjust free list                                */
    230                  OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x6849             LDR      R1,[R1, #+4]
   \   00000030   0x.... 0x....      LDR.W    R2,??DataTable8_1
   \   00000034   0x6011             STR      R1,[R2, #+0]
    231                  pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
   \   00000036   0x2105             MOVS     R1,#+5
   \   00000038   0x7031             STRB     R1,[R6, #+0]
    232                  pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
   \   0000003A   0x8135             STRH     R5,[R6, #+8]
    233                  pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x6071             STR      R1,[R6, #+4]
    234          #if OS_FLAG_NAME_SIZE > 1
    235                  pgrp->OSFlagName[0]  = '?';
   \   00000040   0x213F             MOVS     R1,#+63
   \   00000042   0x72B1             STRB     R1,[R6, #+10]
    236                  pgrp->OSFlagName[1]  = OS_ASCII_NUL;
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x72F1             STRB     R1,[R6, #+11]
    237          #endif
    238                  OS_EXIT_CRITICAL();
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    239                  *perr                = OS_ERR_NONE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7020             STRB     R0,[R4, #+0]
   \   00000050   0xE003             B.N      ??OSFlagCreate_3
    240              } else {
    241                  OS_EXIT_CRITICAL();
   \                     ??OSFlagCreate_2: (+1)
   \   00000052   0x.... 0x....      BL       OS_CPU_SR_Restore
    242                  *perr                = OS_ERR_FLAG_GRP_DEPLETED;
   \   00000056   0x2072             MOVS     R0,#+114
   \   00000058   0x7020             STRB     R0,[R4, #+0]
    243              }
    244              return (pgrp);                                  /* Return pointer to event flag group              */
   \                     ??OSFlagCreate_3: (+1)
   \   0000005A   0x0030             MOVS     R0,R6
   \                     ??OSFlagCreate_1: (+1)
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    245          }
    246          
    247          /*$PAGE*/
    248          /*
    249          *********************************************************************************************************
    250          *                                     DELETE AN EVENT FLAG GROUP
    251          *
    252          * Description: This function deletes an event flag group and readies all tasks pending on the event flag
    253          *              group.
    254          *
    255          * Arguments  : pgrp          is a pointer to the desired event flag group.
    256          *
    257          *              opt           determines delete options as follows:
    258          *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
    259          *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
    260          *                                                    waiting.  In this case, all the tasks pending will be
    261          *                                                    readied.
    262          *
    263          *              perr          is a pointer to an error code that can contain one of the following values:
    264          *                            OS_ERR_NONE               The call was successful and the event flag group was
    265          *                                                      deleted
    266          *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
    267          *                                                      an ISR
    268          *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
    269          *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
    270          *                            OS_ERR_INVALID_OPT        An invalid option was specified
    271          *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
    272          *                                                      group.
    273          *
    274          * Returns    : pgrp          upon error
    275          *              (OS_EVENT *)0 if the event flag group was successfully deleted.
    276          *
    277          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    278          *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
    279          *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
    280          *                 time is directly proportional to the number of tasks waiting on the event flag group.
    281          *********************************************************************************************************
    282          */
    283          
    284          #if OS_FLAG_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    285          OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
    286          {
   \                     OSFlagDel: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
    287              BOOLEAN       tasks_waiting;
    288              OS_FLAG_NODE *pnode;
    289              OS_FLAG_GRP  *pgrp_return;
    290          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    291              OS_CPU_SR     cpu_sr = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    292          #endif
    293          
    294          
    295          
    296          #if OS_ARG_CHK_EN > 0
    297              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    298                  return (pgrp);
    299              }
    300              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    301                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    302                  return (pgrp);
    303              }
    304          #endif
    305              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??OSFlagDel_0
    306                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   00000016   0x200F             MOVS     R0,#+15
   \   00000018   0x7028             STRB     R0,[R5, #+0]
    307                  return (pgrp);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xE064             B.N      ??OSFlagDel_1
    308              }
    309              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
   \                     ??OSFlagDel_0: (+1)
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2805             CMP      R0,#+5
   \   00000022   0xD003             BEQ.N    ??OSFlagDel_2
    310                  *perr = OS_ERR_EVENT_TYPE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7028             STRB     R0,[R5, #+0]
    311                  return (pgrp);
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xE05D             B.N      ??OSFlagDel_1
    312              }
    313              OS_ENTER_CRITICAL();
   \                     ??OSFlagDel_2: (+1)
   \   0000002C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000030   0x0007             MOVS     R7,R0
    314              if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD002             BEQ.N    ??OSFlagDel_3
    315                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
   \   00000038   0xF05F 0x0801      MOVS     R8,#+1
   \   0000003C   0xE001             B.N      ??OSFlagDel_4
    316              } else {
    317                  tasks_waiting = OS_FALSE;                          /* No                                       */
   \                     ??OSFlagDel_3: (+1)
   \   0000003E   0xF05F 0x0800      MOVS     R8,#+0
    318              }
    319              switch (opt) {
   \                     ??OSFlagDel_4: (+1)
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD002             BEQ.N    ??OSFlagDel_5
   \   00000048   0x2E01             CMP      R6,#+1
   \   0000004A   0xD021             BEQ.N    ??OSFlagDel_6
   \   0000004C   0xE046             B.N      ??OSFlagDel_7
    320                  case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
    321                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSFlagDel_5: (+1)
   \   0000004E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000052   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000056   0xD115             BNE.N    ??OSFlagDel_8
    322          #if OS_FLAG_NAME_SIZE > 1
    323                           pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
   \   00000058   0x203F             MOVS     R0,#+63
   \   0000005A   0x72A0             STRB     R0,[R4, #+10]
    324                           pgrp->OSFlagName[1]  = OS_ASCII_NUL;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x72E0             STRB     R0,[R4, #+11]
    325          #endif
    326                           pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x7020             STRB     R0,[R4, #+0]
    327                           pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x6060             STR      R0,[R4, #+4]
    328                           pgrp->OSFlagFlags    = (OS_FLAGS)0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x8120             STRH     R0,[R4, #+8]
    329                           OSFlagFreeList       = pgrp;
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000074   0x6004             STR      R4,[R0, #+0]
    330                           OS_EXIT_CRITICAL();
   \   00000076   0x0038             MOVS     R0,R7
   \   00000078   0x.... 0x....      BL       OS_CPU_SR_Restore
    331                           *perr                = OS_ERR_NONE;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x7028             STRB     R0,[R5, #+0]
    332                           pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
   \   00000080   0x2400             MOVS     R4,#+0
   \   00000082   0xE004             B.N      ??OSFlagDel_9
    333                       } else {
    334                           OS_EXIT_CRITICAL();
   \                     ??OSFlagDel_8: (+1)
   \   00000084   0x0038             MOVS     R0,R7
   \   00000086   0x.... 0x....      BL       OS_CPU_SR_Restore
    335                           *perr                = OS_ERR_TASK_WAITING;
   \   0000008A   0x2049             MOVS     R0,#+73
   \   0000008C   0x7028             STRB     R0,[R5, #+0]
    336                           pgrp_return          = pgrp;
    337                       }
    338                       break;
   \                     ??OSFlagDel_9: (+1)
   \   0000008E   0xE02A             B.N      ??OSFlagDel_10
    339          
    340                  case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
    341                       pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
   \                     ??OSFlagDel_6: (+1)
   \   00000090   0x6866             LDR      R6,[R4, #+4]
   \   00000092   0xE004             B.N      ??OSFlagDel_11
    342                       while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
    343                           (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
   \                     ??OSFlagDel_12: (+1)
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x0030             MOVS     R0,R6
   \   00000098   0x.... 0x....      BL       OS_FlagTaskRdy
    344                           pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
   \   0000009C   0x6836             LDR      R6,[R6, #+0]
    345                       }
   \                     ??OSFlagDel_11: (+1)
   \   0000009E   0x2E00             CMP      R6,#+0
   \   000000A0   0xD1F8             BNE.N    ??OSFlagDel_12
    346          #if OS_FLAG_NAME_SIZE > 1
    347                       pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
   \   000000A2   0x203F             MOVS     R0,#+63
   \   000000A4   0x72A0             STRB     R0,[R4, #+10]
    348                       pgrp->OSFlagName[1]  = OS_ASCII_NUL;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x72E0             STRB     R0,[R4, #+11]
    349          #endif
    350                       pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x7020             STRB     R0,[R4, #+0]
    351                       pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x6060             STR      R0,[R4, #+4]
    352                       pgrp->OSFlagFlags    = (OS_FLAGS)0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x8120             STRH     R0,[R4, #+8]
    353                       OSFlagFreeList       = pgrp;
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   000000BE   0x6004             STR      R4,[R0, #+0]
    354                       OS_EXIT_CRITICAL();
   \   000000C0   0x0038             MOVS     R0,R7
   \   000000C2   0x.... 0x....      BL       OS_CPU_SR_Restore
    355                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   000000C6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000CA   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000CE   0xD101             BNE.N    ??OSFlagDel_13
    356                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   000000D0   0x.... 0x....      BL       OS_Sched
    357                       }
    358                       *perr = OS_ERR_NONE;
   \                     ??OSFlagDel_13: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x7028             STRB     R0,[R5, #+0]
    359                       pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
   \   000000D8   0x2400             MOVS     R4,#+0
    360                       break;
   \   000000DA   0xE004             B.N      ??OSFlagDel_10
    361          
    362                  default:
    363                       OS_EXIT_CRITICAL();
   \                     ??OSFlagDel_7: (+1)
   \   000000DC   0x0038             MOVS     R0,R7
   \   000000DE   0x.... 0x....      BL       OS_CPU_SR_Restore
    364                       *perr                = OS_ERR_INVALID_OPT;
   \   000000E2   0x2007             MOVS     R0,#+7
   \   000000E4   0x7028             STRB     R0,[R5, #+0]
    365                       pgrp_return          = pgrp;
    366                       break;
    367              }
    368              return (pgrp_return);
   \                     ??OSFlagDel_10: (+1)
   \   000000E6   0x0020             MOVS     R0,R4
   \                     ??OSFlagDel_1: (+1)
   \   000000E8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    369          }
    370          #endif
    371          /*$PAGE*/
    372          /*
    373          *********************************************************************************************************
    374          *                                 GET THE NAME OF AN EVENT FLAG GROUP
    375          *
    376          * Description: This function is used to obtain the name assigned to an event flag group
    377          *
    378          * Arguments  : pgrp      is a pointer to the event flag group.
    379          *
    380          *              pname     is a pointer to an ASCII string that will receive the name of the event flag
    381          *                        group.  The string must be able to hold at least OS_FLAG_NAME_SIZE characters.
    382          *
    383          *              perr      is a pointer to an error code that can contain one of the following values:
    384          *
    385          *                        OS_ERR_NONE                if the requested task is resumed
    386          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
    387          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    388          *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
    389          *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
    390          *
    391          * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
    392          *********************************************************************************************************
    393          */
    394          
    395          #if OS_FLAG_NAME_SIZE > 1

   \                                 In section .text, align 2, keep-with-next
    396          INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
    397          {
   \                     OSFlagNameGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
    398              INT8U      len;
    399          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    400              OS_CPU_SR  cpu_sr = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    401          #endif
    402          
    403          
    404          
    405          #if OS_ARG_CHK_EN > 0
    406              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    407                  return (0);
    408              }
    409              if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
    410                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    411                  return (0);
    412              }
    413              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    414                  *perr = OS_ERR_PNAME_NULL;
    415                  return (0);
    416              }
    417          #endif
    418              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSFlagNameGet_0
    419                  *perr = OS_ERR_NAME_GET_ISR;
   \   00000014   0x2011             MOVS     R0,#+17
   \   00000016   0x7020             STRB     R0,[R4, #+0]
    420                  return (0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE019             B.N      ??OSFlagNameGet_1
    421              }
    422              OS_ENTER_CRITICAL();
   \                     ??OSFlagNameGet_0: (+1)
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000020   0x0007             MOVS     R7,R0
    423              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
   \   00000022   0x7828             LDRB     R0,[R5, #+0]
   \   00000024   0x2805             CMP      R0,#+5
   \   00000026   0xD006             BEQ.N    ??OSFlagNameGet_2
    424                  OS_EXIT_CRITICAL();
   \   00000028   0x0038             MOVS     R0,R7
   \   0000002A   0x.... 0x....      BL       OS_CPU_SR_Restore
    425                  *perr = OS_ERR_EVENT_TYPE;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x7020             STRB     R0,[R4, #+0]
    426                  return (0);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE00C             B.N      ??OSFlagNameGet_1
    427              }
    428              len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
   \                     ??OSFlagNameGet_2: (+1)
   \   00000036   0xF115 0x010A      ADDS     R1,R5,#+10
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x.... 0x....      BL       OS_StrCopy
   \   00000040   0x0005             MOVS     R5,R0
    429              OS_EXIT_CRITICAL();
   \   00000042   0x0038             MOVS     R0,R7
   \   00000044   0x.... 0x....      BL       OS_CPU_SR_Restore
    430              *perr = OS_ERR_NONE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x7020             STRB     R0,[R4, #+0]
    431              return (len);
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSFlagNameGet_1: (+1)
   \   00000050   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    432          }
    433          #endif
    434          
    435          /*$PAGE*/
    436          /*
    437          *********************************************************************************************************
    438          *                                 ASSIGN A NAME TO AN EVENT FLAG GROUP
    439          *
    440          * Description: This function assigns a name to an event flag group.
    441          *
    442          * Arguments  : pgrp      is a pointer to the event flag group.
    443          *
    444          *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
    445          *                        group.  The string must be able to hold at least OS_FLAG_NAME_SIZE characters.
    446          *
    447          *              perr      is a pointer to an error code that can contain one of the following values:
    448          *
    449          *                        OS_ERR_NONE                if the requested task is resumed
    450          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
    451          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    452          *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
    453          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    454          *
    455          * Returns    : None
    456          *********************************************************************************************************
    457          */
    458          
    459          #if OS_FLAG_NAME_SIZE > 1

   \                                 In section .text, align 2, keep-with-next
    460          void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
    461          {
   \                     OSFlagNameSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
    462              INT8U      len;
    463          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    464              OS_CPU_SR  cpu_sr = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    465          #endif
    466          
    467          
    468          
    469          #if OS_ARG_CHK_EN > 0
    470              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    471                  return;
    472              }
    473              if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
    474                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    475                  return;
    476              }
    477              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    478                  *perr = OS_ERR_PNAME_NULL;
    479                  return;
    480              }
    481          #endif
    482              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??OSFlagNameSet_0
    483                  *perr = OS_ERR_NAME_SET_ISR;
   \   00000014   0x2012             MOVS     R0,#+18
   \   00000016   0x7020             STRB     R0,[R4, #+0]
    484                  return;
   \   00000018   0xE021             B.N      ??OSFlagNameSet_1
    485              }
    486              OS_ENTER_CRITICAL();
   \                     ??OSFlagNameSet_0: (+1)
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x0007             MOVS     R7,R0
    487              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
   \   00000020   0x7828             LDRB     R0,[R5, #+0]
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD005             BEQ.N    ??OSFlagNameSet_2
    488                  OS_EXIT_CRITICAL();
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Restore
    489                  *perr = OS_ERR_EVENT_TYPE;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7020             STRB     R0,[R4, #+0]
    490                  return;
   \   00000030   0xE015             B.N      ??OSFlagNameSet_1
    491              }
    492              len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
   \                     ??OSFlagNameSet_2: (+1)
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0x.... 0x....      BL       OS_StrLen
    493              if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2810             CMP      R0,#+16
   \   0000003C   0xDB05             BLT.N    ??OSFlagNameSet_3
    494                  OS_EXIT_CRITICAL();
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0x.... 0x....      BL       OS_CPU_SR_Restore
    495                  *perr = OS_ERR_FLAG_NAME_TOO_LONG;
   \   00000044   0x2073             MOVS     R0,#+115
   \   00000046   0x7020             STRB     R0,[R4, #+0]
    496                  return;
   \   00000048   0xE009             B.N      ??OSFlagNameSet_1
    497              }
    498              (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
   \                     ??OSFlagNameSet_3: (+1)
   \   0000004A   0x0031             MOVS     R1,R6
   \   0000004C   0xF115 0x000A      ADDS     R0,R5,#+10
   \   00000050   0x.... 0x....      BL       OS_StrCopy
    499              OS_EXIT_CRITICAL();
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
    500              *perr = OS_ERR_NONE;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x7020             STRB     R0,[R4, #+0]
    501              return;
   \                     ??OSFlagNameSet_1: (+1)
   \   0000005E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    502          }
    503          #endif
    504          
    505          /*$PAGE*/
    506          /*
    507          *********************************************************************************************************
    508          *                                        WAIT ON AN EVENT FLAG GROUP
    509          *
    510          * Description: This function is called to wait for a combination of bits to be set in an event flag
    511          *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
    512          *
    513          * Arguments  : pgrp          is a pointer to the desired event flag group.
    514          *
    515          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
    516          *                            The bits you want are specified by setting the corresponding bits in
    517          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
    518          *                            'flags' would contain 0x03.
    519          *
    520          *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
    521          *                            You can specify the following argument:
    522          *
    523          *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
    524          *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
    525          *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
    526          *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
    527          *
    528          *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
    529          *                                  the call.  Example, to wait for any flag in a group AND then clear
    530          *                                  the flags that are present, set 'wait_type' to:
    531          *
    532          *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
    533          *
    534          *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
    535          *                            desired bit combination.  If you specify 0, however, your task will wait
    536          *                            forever at the specified event flag group or, until a message arrives.
    537          *
    538          *              perr          is a pointer to an error code and can be:
    539          *                            OS_ERR_NONE               The desired bits have been set within the specified
    540          *                                                      'timeout'.
    541          *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
    542          *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
    543          *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
    544          *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
    545          *                                                      'timeout'.
    546          *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
    547          *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
    548          *
    549          * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
    550          *              occurred.
    551          *
    552          * Called from: Task ONLY
    553          *
    554          * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
    555          *                 function NOW returns the flags that were ready INSTEAD of the current state of the
    556          *                 event flags.
    557          *********************************************************************************************************
    558          */
    559          

   \                                 In section .text, align 2, keep-with-next
    560          OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
    561          {
   \                     OSFlagPend: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0007             MOVS     R7,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4691             MOV      R9,R2
   \   0000000C   0x469A             MOV      R10,R3
    562              OS_FLAG_NODE  node;
    563              OS_FLAGS      flags_rdy;
    564              INT8U         result;
    565              INT8U         pend_stat;
    566              BOOLEAN       consume;
    567          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    568              OS_CPU_SR     cpu_sr = 0;
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0x9C10             LDR      R4,[SP, #+64]
    569          #endif
    570          
    571          
    572          
    573          #if OS_ARG_CHK_EN > 0
    574              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    575                  return ((OS_FLAGS)0);
    576              }
    577              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    578                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    579                  return ((OS_FLAGS)0);
    580              }
    581          #endif
    582              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD003             BEQ.N    ??OSFlagPend_0
    583                  *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x7020             STRB     R0,[R4, #+0]
    584                  return ((OS_FLAGS)0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE12F             B.N      ??OSFlagPend_1
    585              }
    586              if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
   \                     ??OSFlagPend_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD003             BEQ.N    ??OSFlagPend_2
    587                  *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
   \   0000002E   0x200D             MOVS     R0,#+13
   \   00000030   0x7020             STRB     R0,[R4, #+0]
    588                  return ((OS_FLAGS)0);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE126             B.N      ??OSFlagPend_1
    589              }
    590              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
   \                     ??OSFlagPend_2: (+1)
   \   00000036   0x7838             LDRB     R0,[R7, #+0]
   \   00000038   0x2805             CMP      R0,#+5
   \   0000003A   0xD003             BEQ.N    ??OSFlagPend_3
    591                  *perr = OS_ERR_EVENT_TYPE;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x7020             STRB     R0,[R4, #+0]
    592                  return ((OS_FLAGS)0);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE11F             B.N      ??OSFlagPend_1
    593              }
    594              result = (INT8U)(wait_type & OS_FLAG_CONSUME);
   \                     ??OSFlagPend_3: (+1)
   \   00000044   0xF019 0x0080      ANDS     R0,R9,#0x80
    595              if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD004             BEQ.N    ??OSFlagPend_4
    596                  wait_type &= ~(INT8U)OS_FLAG_CONSUME;
   \   0000004E   0xF019 0x097F      ANDS     R9,R9,#0x7F
    597                  consume    = OS_TRUE;
   \   00000052   0xF05F 0x0B01      MOVS     R11,#+1
   \   00000056   0xE001             B.N      ??OSFlagPend_5
    598              } else {
    599                  consume    = OS_FALSE;
   \                     ??OSFlagPend_4: (+1)
   \   00000058   0xF05F 0x0B00      MOVS     R11,#+0
    600              }
    601          /*$PAGE*/
    602              OS_ENTER_CRITICAL();
   \                     ??OSFlagPend_5: (+1)
   \   0000005C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000060   0x0005             MOVS     R5,R0
    603              switch (wait_type) {
   \   00000062   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000066   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000006A   0xF000 0x808A      BEQ.W    ??OSFlagPend_6
   \   0000006E   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000072   0xD005             BEQ.N    ??OSFlagPend_7
   \   00000074   0xF0C0 0x80B1      BCC.W    ??OSFlagPend_8
   \   00000078   0xF1B9 0x0F03      CMP      R9,#+3
   \   0000007C   0xD057             BEQ.N    ??OSFlagPend_9
   \   0000007E   0xE0D5             B.N      ??OSFlagPend_10
    604                  case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
    605                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
   \                     ??OSFlagPend_7: (+1)
   \   00000080   0x8938             LDRH     R0,[R7, #+8]
   \   00000082   0xEA18 0x0600      ANDS     R6,R8,R0
    606                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   00000086   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000088   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000008C   0x4546             CMP      R6,R8
   \   0000008E   0xD113             BNE.N    ??OSFlagPend_11
    607                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   00000090   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000094   0xF1BB 0x0F01      CMP      R11,#+1
   \   00000098   0xD102             BNE.N    ??OSFlagPend_12
    608                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
   \   0000009A   0x8938             LDRH     R0,[R7, #+8]
   \   0000009C   0x43B0             BICS     R0,R0,R6
   \   0000009E   0x8138             STRH     R0,[R7, #+8]
    609                           }
    610                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
   \                     ??OSFlagPend_12: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0x8586             STRH     R6,[R0, #+44]
    611                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
   \   000000A8   0x0028             MOVS     R0,R5
   \   000000AA   0x.... 0x....      BL       OS_CPU_SR_Restore
    612                           *perr                   = OS_ERR_NONE;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x7020             STRB     R0,[R4, #+0]
    613                           return (flags_rdy);
   \   000000B2   0x0030             MOVS     R0,R6
   \   000000B4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B6   0xE0E5             B.N      ??OSFlagPend_1
    614                       } else {                                      /* Block task until events occur or timeout */
    615                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
   \                     ??OSFlagPend_11: (+1)
   \   000000B8   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000BC   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   000000C0   0x464B             MOV      R3,R9
   \   000000C2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000C4   0x4642             MOV      R2,R8
   \   000000C6   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000C8   0xA901             ADD      R1,SP,#+4
   \   000000CA   0x0038             MOVS     R0,R7
   \   000000CC   0x.... 0x....      BL       OS_FlagBlock
    616                           OS_EXIT_CRITICAL();
   \   000000D0   0x0028             MOVS     R0,R5
   \   000000D2   0x.... 0x....      BL       OS_CPU_SR_Restore
    617                       }
    618                       break;
    619          
    620                  case OS_FLAG_WAIT_SET_ANY:
    621                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
    622                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
    623                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
    624                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    625                           }
    626                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    627                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    628                           *perr                   = OS_ERR_NONE;
    629                           return (flags_rdy);
    630                       } else {                                      /* Block task until events occur or timeout */
    631                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    632                           OS_EXIT_CRITICAL();
    633                       }
    634                       break;
    635          
    636          #if OS_FLAG_WAIT_CLR_EN > 0
    637                  case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
    638                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
    639                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
    640                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
    641                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
    642                           }
    643                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    644                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    645                           *perr                   = OS_ERR_NONE;
    646                           return (flags_rdy);
    647                       } else {                                      /* Block task until events occur or timeout */
    648                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    649                           OS_EXIT_CRITICAL();
    650                       }
    651                       break;
    652          
    653                  case OS_FLAG_WAIT_CLR_ANY:
    654                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
    655                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
    656                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
    657                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
    658                           }
    659                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    660                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    661                           *perr                   = OS_ERR_NONE;
    662                           return (flags_rdy);
    663                       } else {                                      /* Block task until events occur or timeout */
    664                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    665                           OS_EXIT_CRITICAL();
    666                       }
    667                       break;
    668          #endif
    669          
    670                  default:
    671                       OS_EXIT_CRITICAL();
    672                       flags_rdy = (OS_FLAGS)0;
    673                       *perr      = OS_ERR_FLAG_WAIT_TYPE;
    674                       return (flags_rdy);
    675              }
    676          /*$PAGE*/
    677              OS_Sched();                                            /* Find next HPT ready to run               */
   \                     ??OSFlagPend_13: (+1)
   \   000000D6   0x.... 0x....      BL       OS_Sched
    678              OS_ENTER_CRITICAL();
   \   000000DA   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000000DE   0x0005             MOVS     R5,R0
    679              if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xF890 0x0031      LDRB     R0,[R0, #+49]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xF000 0x80AC      BEQ.W    ??OSFlagPend_14
    680                  pend_stat                = OSTCBCur->OSTCBStatPend;
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0xF890 0x7031      LDRB     R7,[R0, #+49]
    681                  OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \   00000100   0x6809             LDR      R1,[R1, #+0]
   \   00000102   0xF881 0x0031      STRB     R0,[R1, #+49]
    682                  OS_FlagUnlink(&node);
   \   00000106   0xA801             ADD      R0,SP,#+4
   \   00000108   0x.... 0x....      BL       OS_FlagUnlink
    683                  OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \   00000112   0x6809             LDR      R1,[R1, #+0]
   \   00000114   0xF881 0x0030      STRB     R0,[R1, #+48]
    684                  OS_EXIT_CRITICAL();
   \   00000118   0x0028             MOVS     R0,R5
   \   0000011A   0x.... 0x....      BL       OS_CPU_SR_Restore
    685                  flags_rdy                = (OS_FLAGS)0;
   \   0000011E   0x2600             MOVS     R6,#+0
    686                  switch (pend_stat) {
   \   00000120   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000122   0x2F02             CMP      R7,#+2
   \   00000124   0xF040 0x808B      BNE.W    ??OSFlagPend_15
    687                      case OS_STAT_PEND_ABORT:
    688                           *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
   \   00000128   0x200E             MOVS     R0,#+14
   \   0000012A   0x7020             STRB     R0,[R4, #+0]
    689                           break;
   \   0000012C   0xE089             B.N      ??OSFlagPend_16
   \                     ??OSFlagPend_9: (+1)
   \   0000012E   0x8938             LDRH     R0,[R7, #+8]
   \   00000130   0xEA18 0x0600      ANDS     R6,R8,R0
   \   00000134   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000136   0x2E00             CMP      R6,#+0
   \   00000138   0xD013             BEQ.N    ??OSFlagPend_17
   \   0000013A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000013E   0xF1BB 0x0F01      CMP      R11,#+1
   \   00000142   0xD102             BNE.N    ??OSFlagPend_18
   \   00000144   0x8938             LDRH     R0,[R7, #+8]
   \   00000146   0x43B0             BICS     R0,R0,R6
   \   00000148   0x8138             STRH     R0,[R7, #+8]
   \                     ??OSFlagPend_18: (+1)
   \   0000014A   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   0000014E   0x6800             LDR      R0,[R0, #+0]
   \   00000150   0x8586             STRH     R6,[R0, #+44]
   \   00000152   0x0028             MOVS     R0,R5
   \   00000154   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000158   0x2000             MOVS     R0,#+0
   \   0000015A   0x7020             STRB     R0,[R4, #+0]
   \   0000015C   0x0030             MOVS     R0,R6
   \   0000015E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000160   0xE090             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_17: (+1)
   \   00000162   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000166   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   0000016A   0x464B             MOV      R3,R9
   \   0000016C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000016E   0x4642             MOV      R2,R8
   \   00000170   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000172   0xA901             ADD      R1,SP,#+4
   \   00000174   0x0038             MOVS     R0,R7
   \   00000176   0x.... 0x....      BL       OS_FlagBlock
   \   0000017A   0x0028             MOVS     R0,R5
   \   0000017C   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000180   0xE7A9             B.N      ??OSFlagPend_13
   \                     ??OSFlagPend_6: (+1)
   \   00000182   0x8938             LDRH     R0,[R7, #+8]
   \   00000184   0xEA38 0x0600      BICS     R6,R8,R0
   \   00000188   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000018A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000018E   0x4546             CMP      R6,R8
   \   00000190   0xD113             BNE.N    ??OSFlagPend_19
   \   00000192   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000196   0xF1BB 0x0F01      CMP      R11,#+1
   \   0000019A   0xD102             BNE.N    ??OSFlagPend_20
   \   0000019C   0x8938             LDRH     R0,[R7, #+8]
   \   0000019E   0x4330             ORRS     R0,R6,R0
   \   000001A0   0x8138             STRH     R0,[R7, #+8]
   \                     ??OSFlagPend_20: (+1)
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0x8586             STRH     R6,[R0, #+44]
   \   000001AA   0x0028             MOVS     R0,R5
   \   000001AC   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0x7020             STRB     R0,[R4, #+0]
   \   000001B4   0x0030             MOVS     R0,R6
   \   000001B6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001B8   0xE064             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_19: (+1)
   \   000001BA   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000001BE   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   000001C2   0x464B             MOV      R3,R9
   \   000001C4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001C6   0x4642             MOV      R2,R8
   \   000001C8   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000001CA   0xA901             ADD      R1,SP,#+4
   \   000001CC   0x0038             MOVS     R0,R7
   \   000001CE   0x.... 0x....      BL       OS_FlagBlock
   \   000001D2   0x0028             MOVS     R0,R5
   \   000001D4   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   000001D8   0xE77D             B.N      ??OSFlagPend_13
   \                     ??OSFlagPend_8: (+1)
   \   000001DA   0x8938             LDRH     R0,[R7, #+8]
   \   000001DC   0xEA38 0x0600      BICS     R6,R8,R0
   \   000001E0   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000001E2   0x2E00             CMP      R6,#+0
   \   000001E4   0xD012             BEQ.N    ??OSFlagPend_21
   \   000001E6   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000001EA   0xF1BB 0x0F01      CMP      R11,#+1
   \   000001EE   0xD102             BNE.N    ??OSFlagPend_22
   \   000001F0   0x8938             LDRH     R0,[R7, #+8]
   \   000001F2   0x4330             ORRS     R0,R6,R0
   \   000001F4   0x8138             STRH     R0,[R7, #+8]
   \                     ??OSFlagPend_22: (+1)
   \   000001F6   0x....             LDR.N    R0,??DataTable8_3
   \   000001F8   0x6800             LDR      R0,[R0, #+0]
   \   000001FA   0x8586             STRH     R6,[R0, #+44]
   \   000001FC   0x0028             MOVS     R0,R5
   \   000001FE   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000202   0x2000             MOVS     R0,#+0
   \   00000204   0x7020             STRB     R0,[R4, #+0]
   \   00000206   0x0030             MOVS     R0,R6
   \   00000208   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000020A   0xE03B             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_21: (+1)
   \   0000020C   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000210   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   00000214   0x464B             MOV      R3,R9
   \   00000216   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000218   0x4642             MOV      R2,R8
   \   0000021A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000021C   0xA901             ADD      R1,SP,#+4
   \   0000021E   0x0038             MOVS     R0,R7
   \   00000220   0x.... 0x....      BL       OS_FlagBlock
   \   00000224   0x0028             MOVS     R0,R5
   \   00000226   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   0000022A   0xE754             B.N      ??OSFlagPend_13
   \                     ??OSFlagPend_10: (+1)
   \   0000022C   0x0028             MOVS     R0,R5
   \   0000022E   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000232   0x2600             MOVS     R6,#+0
   \   00000234   0x206F             MOVS     R0,#+111
   \   00000236   0x7020             STRB     R0,[R4, #+0]
   \   00000238   0x0030             MOVS     R0,R6
   \   0000023A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000023C   0xE022             B.N      ??OSFlagPend_1
    690          
    691                      case OS_STAT_PEND_TO:
    692                      default:
    693                           *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
   \                     ??OSFlagPend_15: (+1)
   \   0000023E   0x200A             MOVS     R0,#+10
   \   00000240   0x7020             STRB     R0,[R4, #+0]
    694                           break;
    695                  }
    696                  return (flags_rdy);
   \                     ??OSFlagPend_16: (+1)
   \   00000242   0x0030             MOVS     R0,R6
   \   00000244   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000246   0xE01D             B.N      ??OSFlagPend_1
    697              }
    698              flags_rdy = OSTCBCur->OSTCBFlagsRdy;
   \                     ??OSFlagPend_14: (+1)
   \   00000248   0x....             LDR.N    R0,??DataTable8_3
   \   0000024A   0x6800             LDR      R0,[R0, #+0]
   \   0000024C   0x8D86             LDRH     R6,[R0, #+44]
    699              if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
   \   0000024E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000252   0xF1BB 0x0F01      CMP      R11,#+1
   \   00000256   0xD10E             BNE.N    ??OSFlagPend_23
    700                  switch (wait_type) {
   \   00000258   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000025C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000260   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000264   0xD911             BLS.N    ??OSFlagPend_24
   \   00000266   0xF1B9 0x0902      SUBS     R9,R9,#+2
   \   0000026A   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000026E   0xD810             BHI.N    ??OSFlagPend_25
    701                      case OS_FLAG_WAIT_SET_ALL:
    702                      case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
    703                           pgrp->OSFlagFlags &= ~flags_rdy;
   \                     ??OSFlagPend_26: (+1)
   \   00000270   0x8938             LDRH     R0,[R7, #+8]
   \   00000272   0x43B0             BICS     R0,R0,R6
   \   00000274   0x8138             STRH     R0,[R7, #+8]
    704                           break;
    705          
    706          #if OS_FLAG_WAIT_CLR_EN > 0
    707                      case OS_FLAG_WAIT_CLR_ALL:
    708                      case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
    709                           pgrp->OSFlagFlags |=  flags_rdy;
    710                           break;
    711          #endif
    712                      default:
    713                           OS_EXIT_CRITICAL();
    714                           *perr = OS_ERR_FLAG_WAIT_TYPE;
    715                           return ((OS_FLAGS)0);
    716                  }
    717              }
    718              OS_EXIT_CRITICAL();
   \                     ??OSFlagPend_23: (+1)
   \   00000276   0x0028             MOVS     R0,R5
   \   00000278   0x.... 0x....      BL       OS_CPU_SR_Restore
    719              *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
   \   0000027C   0x2000             MOVS     R0,#+0
   \   0000027E   0x7020             STRB     R0,[R4, #+0]
    720              return (flags_rdy);
   \   00000280   0x0030             MOVS     R0,R6
   \   00000282   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagPend_1: (+1)
   \   00000284   0xB007             ADD      SP,SP,#+28
   \   00000286   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??OSFlagPend_24: (+1)
   \   0000028A   0x8938             LDRH     R0,[R7, #+8]
   \   0000028C   0x4330             ORRS     R0,R6,R0
   \   0000028E   0x8138             STRH     R0,[R7, #+8]
   \   00000290   0xE7F1             B.N      ??OSFlagPend_23
   \                     ??OSFlagPend_25: (+1)
   \   00000292   0x0028             MOVS     R0,R5
   \   00000294   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000298   0x206F             MOVS     R0,#+111
   \   0000029A   0x7020             STRB     R0,[R4, #+0]
   \   0000029C   0x2000             MOVS     R0,#+0
   \   0000029E   0xE7F1             B.N      ??OSFlagPend_1
    721          }
    722          /*$PAGE*/
    723          /*
    724          *********************************************************************************************************
    725          *                               GET FLAGS WHO CAUSED TASK TO BECOME READY
    726          *
    727          * Description: This function is called to obtain the flags that caused the task to become ready to run.
    728          *              In other words, this function allows you to tell "Who done it!".
    729          *
    730          * Arguments  : None
    731          *
    732          * Returns    : The flags that caused the task to be ready.
    733          *
    734          * Called from: Task ONLY
    735          *********************************************************************************************************
    736          */
    737          

   \                                 In section .text, align 2, keep-with-next
    738          OS_FLAGS  OSFlagPendGetFlagsRdy (void)
    739          {
   \                     OSFlagPendGetFlagsRdy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    740              OS_FLAGS      flags;
    741          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    742              OS_CPU_SR     cpu_sr = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    743          #endif
    744          
    745          
    746          
    747              OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
    748              flags = OSTCBCur->OSTCBFlagsRdy;
   \   00000008   0x....             LDR.N    R1,??DataTable8_3
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x8D8C             LDRH     R4,[R1, #+44]
    749              OS_EXIT_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Restore
    750              return (flags);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    751          }
    752          
    753          /*$PAGE*/
    754          /*
    755          *********************************************************************************************************
    756          *                                         POST EVENT FLAG BIT(S)
    757          *
    758          * Description: This function is called to set or clear some bits in an event flag group.  The bits to
    759          *              set or clear are specified by a 'bit mask'.
    760          *
    761          * Arguments  : pgrp          is a pointer to the desired event flag group.
    762          *
    763          *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
    764          *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
    765          *                            and 5 you would set 'flags' to:
    766          *
    767          *                                0x31     (note, bit 0 is least significant bit)
    768          *
    769          *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
    770          *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
    771          *                            4 and 5 you would specify 'flags' as:
    772          *
    773          *                                0x31     (note, bit 0 is least significant bit)
    774          *
    775          *              opt           indicates whether the flags will be:
    776          *                                set     (OS_FLAG_SET) or
    777          *                                cleared (OS_FLAG_CLR)
    778          *
    779          *              perr          is a pointer to an error code and can be:
    780          *                            OS_ERR_NONE                The call was successfull
    781          *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
    782          *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
    783          *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
    784          *
    785          * Returns    : the new value of the event flags bits that are still set.
    786          *
    787          * Called From: Task or ISR
    788          *
    789          * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
    790          *                 flag group.
    791          *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
    792          *                 the event flag group.
    793          *********************************************************************************************************
    794          */

   \                                 In section .text, align 2, keep-with-next
    795          OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
    796          {
   \                     OSFlagPost: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001C             MOVS     R4,R3
    797              OS_FLAG_NODE *pnode;
    798              BOOLEAN       sched;
    799              OS_FLAGS      flags_cur;
    800              OS_FLAGS      flags_rdy;
    801              BOOLEAN       rdy;
    802          #if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    803              OS_CPU_SR     cpu_sr = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
    804          #endif
    805          
    806          
    807          
    808          #if OS_ARG_CHK_EN > 0
    809              if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
    810                  return ((OS_FLAGS)0);
    811              }
    812              if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
    813                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    814                  return ((OS_FLAGS)0);
    815              }
    816          #endif
    817              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
   \   0000000E   0x7828             LDRB     R0,[R5, #+0]
   \   00000010   0x2805             CMP      R0,#+5
   \   00000012   0xD003             BEQ.N    ??OSFlagPost_0
    818                  *perr = OS_ERR_EVENT_TYPE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7020             STRB     R0,[R4, #+0]
    819                  return ((OS_FLAGS)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE088             B.N      ??OSFlagPost_1
    820              }
    821          /*$PAGE*/
    822              OS_ENTER_CRITICAL();
   \                     ??OSFlagPost_0: (+1)
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000020   0x0006             MOVS     R6,R0
    823              switch (opt) {
   \   00000022   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000026   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002A   0xD003             BEQ.N    ??OSFlagPost_2
   \   0000002C   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000030   0xD007             BEQ.N    ??OSFlagPost_3
   \   00000032   0xE00A             B.N      ??OSFlagPost_4
    824                  case OS_FLAG_CLR:
    825                       pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
   \                     ??OSFlagPost_2: (+1)
   \   00000034   0x8928             LDRH     R0,[R5, #+8]
   \   00000036   0x43B8             BICS     R0,R0,R7
   \   00000038   0x8128             STRH     R0,[R5, #+8]
    826                       break;
    827          
    828                  case OS_FLAG_SET:
    829                       pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
    830                       break;
    831          
    832                  default:
    833                       OS_EXIT_CRITICAL();                     /* INVALID option                                 */
    834                       *perr = OS_ERR_FLAG_INVALID_OPT;
    835                       return ((OS_FLAGS)0);
    836              }
    837              sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
   \                     ??OSFlagPost_5: (+1)
   \   0000003A   0x2700             MOVS     R7,#+0
    838              pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
   \   0000003C   0xF8D5 0x8004      LDR      R8,[R5, #+4]
   \   00000040   0xE01D             B.N      ??OSFlagPost_6
   \                     ??OSFlagPost_3: (+1)
   \   00000042   0x8928             LDRH     R0,[R5, #+8]
   \   00000044   0x4338             ORRS     R0,R7,R0
   \   00000046   0x8128             STRH     R0,[R5, #+8]
   \   00000048   0xE7F7             B.N      ??OSFlagPost_5
   \                     ??OSFlagPost_4: (+1)
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000050   0x2071             MOVS     R0,#+113
   \   00000052   0x7020             STRB     R0,[R4, #+0]
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE06A             B.N      ??OSFlagPost_1
    839              while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
    840                  switch (pnode->OSFlagNodeWaitType) {
    841                      case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
    842                           flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
   \                     ??OSFlagPost_7: (+1)
   \   00000058   0x8928             LDRH     R0,[R5, #+8]
   \   0000005A   0xF8B8 0x1010      LDRH     R1,[R8, #+16]
   \   0000005E   0x4001             ANDS     R1,R1,R0
    843                           if (flags_rdy == pnode->OSFlagNodeFlags) {
   \   00000060   0xF8B8 0x0010      LDRH     R0,[R8, #+16]
   \   00000064   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000066   0x4281             CMP      R1,R0
   \   00000068   0xD107             BNE.N    ??OSFlagPost_8
    844                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
   \   0000006A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x.... 0x....      BL       OS_FlagTaskRdy
    845                               if (rdy == OS_TRUE) {
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD100             BNE.N    ??OSFlagPost_8
    846                                   sched = OS_TRUE;                     /* When done we will reschedule          */
   \   00000078   0x2701             MOVS     R7,#+1
    847                               }
    848                           }
    849                           break;
    850          
    851                      case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
    852                           flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
    853                           if (flags_rdy != (OS_FLAGS)0) {
    854                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    855                               if (rdy == OS_TRUE) {
    856                                   sched = OS_TRUE;                     /* When done we will reschedule          */
    857                               }
    858                           }
    859                           break;
    860          
    861          #if OS_FLAG_WAIT_CLR_EN > 0
    862                      case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
    863                           flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
    864                           if (flags_rdy == pnode->OSFlagNodeFlags) {
    865                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    866                               if (rdy == OS_TRUE) {
    867                                   sched = OS_TRUE;                     /* When done we will reschedule          */
    868                               }
    869                           }
    870                           break;
    871          
    872                      case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
    873                           flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
    874                           if (flags_rdy != (OS_FLAGS)0) {
    875                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    876                               if (rdy == OS_TRUE) {
    877                                   sched = OS_TRUE;                     /* When done we will reschedule          */
    878                               }
    879                           }
    880                           break;
    881          #endif
    882                      default:
    883                           OS_EXIT_CRITICAL();
    884                           *perr = OS_ERR_FLAG_WAIT_TYPE;
    885                           return ((OS_FLAGS)0);
    886                  }
    887                  pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
   \                     ??OSFlagPost_8: (+1)
   \                     ??OSFlagPost_9: (+1)
   \   0000007A   0xF8D8 0x8000      LDR      R8,[R8, #+0]
   \                     ??OSFlagPost_6: (+1)
   \   0000007E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000082   0xD041             BEQ.N    ??OSFlagPost_10
   \   00000084   0xF898 0x0012      LDRB     R0,[R8, #+18]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD014             BEQ.N    ??OSFlagPost_11
   \   0000008C   0x2802             CMP      R0,#+2
   \   0000008E   0xD0E3             BEQ.N    ??OSFlagPost_7
   \   00000090   0xD323             BCC.N    ??OSFlagPost_12
   \   00000092   0x2803             CMP      R0,#+3
   \   00000094   0xD131             BNE.N    ??OSFlagPost_13
   \                     ??OSFlagPost_14: (+1)
   \   00000096   0x8928             LDRH     R0,[R5, #+8]
   \   00000098   0xF8B8 0x1010      LDRH     R1,[R8, #+16]
   \   0000009C   0x4001             ANDS     R1,R1,R0
   \   0000009E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000A0   0x2900             CMP      R1,#+0
   \   000000A2   0xD007             BEQ.N    ??OSFlagPost_15
   \   000000A4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000A6   0x4640             MOV      R0,R8
   \   000000A8   0x.... 0x....      BL       OS_FlagTaskRdy
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xD100             BNE.N    ??OSFlagPost_15
   \   000000B2   0x2701             MOVS     R7,#+1
   \                     ??OSFlagPost_15: (+1)
   \   000000B4   0xE7E1             B.N      ??OSFlagPost_9
   \                     ??OSFlagPost_11: (+1)
   \   000000B6   0x8928             LDRH     R0,[R5, #+8]
   \   000000B8   0xF8B8 0x1010      LDRH     R1,[R8, #+16]
   \   000000BC   0x4381             BICS     R1,R1,R0
   \   000000BE   0xF8B8 0x0010      LDRH     R0,[R8, #+16]
   \   000000C2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000C4   0x4281             CMP      R1,R0
   \   000000C6   0xD107             BNE.N    ??OSFlagPost_16
   \   000000C8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000CA   0x4640             MOV      R0,R8
   \   000000CC   0x.... 0x....      BL       OS_FlagTaskRdy
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0x2801             CMP      R0,#+1
   \   000000D4   0xD100             BNE.N    ??OSFlagPost_16
   \   000000D6   0x2701             MOVS     R7,#+1
   \                     ??OSFlagPost_16: (+1)
   \   000000D8   0xE7CF             B.N      ??OSFlagPost_9
   \                     ??OSFlagPost_12: (+1)
   \   000000DA   0x8928             LDRH     R0,[R5, #+8]
   \   000000DC   0xF8B8 0x1010      LDRH     R1,[R8, #+16]
   \   000000E0   0x4381             BICS     R1,R1,R0
   \   000000E2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000E4   0x2900             CMP      R1,#+0
   \   000000E6   0xD007             BEQ.N    ??OSFlagPost_17
   \   000000E8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000EA   0x4640             MOV      R0,R8
   \   000000EC   0x.... 0x....      BL       OS_FlagTaskRdy
   \   000000F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F2   0x2801             CMP      R0,#+1
   \   000000F4   0xD100             BNE.N    ??OSFlagPost_17
   \   000000F6   0x2701             MOVS     R7,#+1
   \                     ??OSFlagPost_17: (+1)
   \   000000F8   0xE7BF             B.N      ??OSFlagPost_9
   \                     ??OSFlagPost_13: (+1)
   \   000000FA   0x0030             MOVS     R0,R6
   \   000000FC   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000100   0x206F             MOVS     R0,#+111
   \   00000102   0x7020             STRB     R0,[R4, #+0]
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xE012             B.N      ??OSFlagPost_1
    888              }
    889              OS_EXIT_CRITICAL();
   \                     ??OSFlagPost_10: (+1)
   \   00000108   0x0030             MOVS     R0,R6
   \   0000010A   0x.... 0x....      BL       OS_CPU_SR_Restore
    890              if (sched == OS_TRUE) {
   \   0000010E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000110   0x2F01             CMP      R7,#+1
   \   00000112   0xD101             BNE.N    ??OSFlagPost_18
    891                  OS_Sched();
   \   00000114   0x.... 0x....      BL       OS_Sched
    892              }
    893              OS_ENTER_CRITICAL();
   \                     ??OSFlagPost_18: (+1)
   \   00000118   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000011C   0x0006             MOVS     R6,R0
    894              flags_cur = pgrp->OSFlagFlags;
   \   0000011E   0x892D             LDRH     R5,[R5, #+8]
    895              OS_EXIT_CRITICAL();
   \   00000120   0x0030             MOVS     R0,R6
   \   00000122   0x.... 0x....      BL       OS_CPU_SR_Restore
    896              *perr     = OS_ERR_NONE;
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x7020             STRB     R0,[R4, #+0]
    897              return (flags_cur);
   \   0000012A   0x0028             MOVS     R0,R5
   \   0000012C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagPost_1: (+1)
   \   0000012E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    898          }
    899          /*$PAGE*/
    900          /*
    901          *********************************************************************************************************
    902          *                                           QUERY EVENT FLAG
    903          *
    904          * Description: This function is used to check the value of the event flag group.
    905          *
    906          * Arguments  : pgrp         is a pointer to the desired event flag group.
    907          *
    908          *              perr          is a pointer to an error code returned to the called:
    909          *                            OS_ERR_NONE                The call was successfull
    910          *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
    911          *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
    912          *
    913          * Returns    : The current value of the event flag group.
    914          *
    915          * Called From: Task or ISR
    916          *********************************************************************************************************
    917          */
    918          
    919          #if OS_FLAG_QUERY_EN > 0

   \                                 In section .text, align 2, keep-with-next
    920          OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
    921          {
   \                     OSFlagQuery: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    922              OS_FLAGS   flags;
    923          #if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    924              OS_CPU_SR  cpu_sr = 0;
   \   00000006   0x2000             MOVS     R0,#+0
    925          #endif
    926          
    927          
    928          
    929          #if OS_ARG_CHK_EN > 0
    930              if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
    931                  return ((OS_FLAGS)0);
    932              }
    933              if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
    934                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    935                  return ((OS_FLAGS)0);
    936              }
    937          #endif
    938              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2805             CMP      R0,#+5
   \   0000000C   0xD003             BEQ.N    ??OSFlagQuery_0
    939                  *perr = OS_ERR_EVENT_TYPE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7028             STRB     R0,[R5, #+0]
    940                  return ((OS_FLAGS)0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE008             B.N      ??OSFlagQuery_1
    941              }
    942              OS_ENTER_CRITICAL();
   \                     ??OSFlagQuery_0: (+1)
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
    943              flags = pgrp->OSFlagFlags;
   \   0000001A   0x8924             LDRH     R4,[R4, #+8]
    944              OS_EXIT_CRITICAL();
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Restore
    945              *perr = OS_ERR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x7028             STRB     R0,[R5, #+0]
    946              return (flags);                               /* Return the current value of the event flags       */
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagQuery_1: (+1)
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    947          }
    948          #endif
    949          
    950          /*$PAGE*/
    951          /*
    952          *********************************************************************************************************
    953          *                         SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
    954          *
    955          * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
    956          *              event flag bit(s) are set.
    957          *
    958          * Arguments  : pgrp          is a pointer to the desired event flag group.
    959          *
    960          *              pnode         is a pointer to a structure which contains data about the task waiting for
    961          *                            event flag bit(s) to be set.
    962          *
    963          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
    964          *                            The bits you want are specified by setting the corresponding bits in
    965          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
    966          *                            'flags' would contain 0x03.
    967          *
    968          *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
    969          *                            to be set/cleared.
    970          *                            You can specify the following argument:
    971          *
    972          *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
    973          *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
    974          *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
    975          *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
    976          *
    977          *              timeout       is the desired amount of time that the task will wait for the event flag
    978          *                            bit(s) to be set.
    979          *
    980          * Returns    : none
    981          *
    982          * Called by  : OSFlagPend()  OS_FLAG.C
    983          *
    984          * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
    985          *********************************************************************************************************
    986          */
    987          

   \                                 In section .text, align 2, keep-with-next
    988          static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
    989          {
   \                     OS_FlagBlock: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    990              OS_FLAG_NODE  *pnode_next;
    991              INT8U          y;
    992          
    993          
    994              OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
   \   00000002   0x....             LDR.N    R4,??DataTable8_3
   \   00000004   0x6824             LDR      R4,[R4, #+0]
   \   00000006   0xF894 0x4030      LDRB     R4,[R4, #+48]
   \   0000000A   0xF054 0x0420      ORRS     R4,R4,#0x20
   \   0000000E   0x....             LDR.N    R5,??DataTable8_3
   \   00000010   0x682D             LDR      R5,[R5, #+0]
   \   00000012   0xF885 0x4030      STRB     R4,[R5, #+48]
    995              OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0x....             LDR.N    R5,??DataTable8_3
   \   0000001A   0x682D             LDR      R5,[R5, #+0]
   \   0000001C   0xF885 0x4031      STRB     R4,[R5, #+49]
    996              OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
   \   00000020   0x9C02             LDR      R4,[SP, #+8]
   \   00000022   0x....             LDR.N    R5,??DataTable8_3
   \   00000024   0x682D             LDR      R5,[R5, #+0]
   \   00000026   0x85EC             STRH     R4,[R5, #+46]
    997          #if OS_TASK_DEL_EN > 0
    998              OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
   \   00000028   0x....             LDR.N    R4,??DataTable8_3
   \   0000002A   0x6824             LDR      R4,[R4, #+0]
   \   0000002C   0x62A1             STR      R1,[R4, #+40]
    999          #endif
   1000              pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
   \   0000002E   0x820A             STRH     R2,[R1, #+16]
   1001              pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
   \   00000030   0x748B             STRB     R3,[R1, #+18]
   1002              pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
   \   00000032   0x....             LDR.N    R2,??DataTable8_3
   \   00000034   0x6812             LDR      R2,[R2, #+0]
   \   00000036   0x608A             STR      R2,[R1, #+8]
   1003              pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
   \   00000038   0x6842             LDR      R2,[R0, #+4]
   \   0000003A   0x600A             STR      R2,[R1, #+0]
   1004              pnode->OSFlagNodePrev     = (void *)0;
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0x604A             STR      R2,[R1, #+4]
   1005              pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1006              pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
   \   00000042   0x6842             LDR      R2,[R0, #+4]
   1007              if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
   \   00000044   0x2A00             CMP      R2,#+0
   \   00000046   0xD000             BEQ.N    ??OS_FlagBlock_0
   1008                  pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
   \   00000048   0x6051             STR      R1,[R2, #+4]
   1009              }
   1010              pgrp->OSFlagWaitList = (void *)pnode;
   \                     ??OS_FlagBlock_0: (+1)
   \   0000004A   0x6041             STR      R1,[R0, #+4]
   1011          
   1012              y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
   \   0000004C   0x....             LDR.N    R0,??DataTable8_3
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF890 0x0034      LDRB     R0,[R0, #+52]
   1013              OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
   \   00000054   0x....             LDR.N    R1,??DataTable8_4
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x5C41             LDRB     R1,[R0, R1]
   \   0000005A   0x....             LDR.N    R2,??DataTable8_3
   \   0000005C   0x6812             LDR      R2,[R2, #+0]
   \   0000005E   0xF892 0x2035      LDRB     R2,[R2, #+53]
   \   00000062   0x4391             BICS     R1,R1,R2
   \   00000064   0x....             LDR.N    R2,??DataTable8_4
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0x5481             STRB     R1,[R0, R2]
   1014              if (OSRdyTbl[y] == 0x00) {
   \   0000006A   0x....             LDR.N    R1,??DataTable8_4
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x5C40             LDRB     R0,[R0, R1]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD108             BNE.N    ??OS_FlagBlock_1
   1015                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
   \   00000074   0x....             LDR.N    R0,??DataTable8_5
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x....             LDR.N    R1,??DataTable8_3
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0xF891 0x1036      LDRB     R1,[R1, #+54]
   \   00000080   0x4388             BICS     R0,R0,R1
   \   00000082   0x....             LDR.N    R1,??DataTable8_5
   \   00000084   0x7008             STRB     R0,[R1, #+0]
   1016              }
   1017          }
   \                     ??OS_FlagBlock_1: (+1)
   \   00000086   0xBC30             POP      {R4,R5}
   \   00000088   0x4770             BX       LR               ;; return
   1018          
   1019          /*$PAGE*/
   1020          /*
   1021          *********************************************************************************************************
   1022          *                                    INITIALIZE THE EVENT FLAG MODULE
   1023          *
   1024          * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
   1025          *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
   1026          *
   1027          * Arguments  : none
   1028          *
   1029          * Returns    : none
   1030          *
   1031          * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
   1032          *********************************************************************************************************
   1033          */
   1034          

   \                                 In section .text, align 2, keep-with-next
   1035          void  OS_FlagInit (void)
   1036          {
   \                     OS_FlagInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1037          #if OS_MAX_FLAGS == 1
   1038              OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
   1039              OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   1040              OSFlagFreeList->OSFlagWaitList = (void *)0;
   1041              OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
   1042          #if OS_FLAG_NAME_SIZE > 1
   1043              OSFlagFreeList->OSFlagName[0]  = '?';
   1044              OSFlagFreeList->OSFlagName[1]  = OS_ASCII_NUL;
   1045          #endif
   1046          #endif
   1047          
   1048          #if OS_MAX_FLAGS >= 2
   1049              INT16U       i;
   1050              OS_FLAG_GRP *pgrp1;
   1051              OS_FLAG_GRP *pgrp2;
   1052          
   1053          
   1054              OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
   \   00000002   0x218C             MOVS     R1,#+140
   \   00000004   0x....             LDR.N    R0,??DataTable8_6
   \   00000006   0x.... 0x....      BL       OS_MemClr
   1055              pgrp1 = &OSFlagTbl[0];
   \   0000000A   0x....             LDR.N    R1,??DataTable8_6
   1056              pgrp2 = &OSFlagTbl[1];
   \   0000000C   0x....             LDR.N    R2,??DataTable8_7
   1057              for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE009             B.N      ??OS_FlagInit_0
   1058                  pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \                     ??OS_FlagInit_1: (+1)
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x700B             STRB     R3,[R1, #+0]
   1059                  pgrp1->OSFlagWaitList = (void *)pgrp2;
   \   00000016   0x604A             STR      R2,[R1, #+4]
   1060          #if OS_FLAG_NAME_SIZE > 1
   1061                  pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
   \   00000018   0x233F             MOVS     R3,#+63
   \   0000001A   0x728B             STRB     R3,[R1, #+10]
   1062                  pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x72CB             STRB     R3,[R1, #+11]
   1063          #endif
   1064                  pgrp1++;
   \   00000020   0x311C             ADDS     R1,R1,#+28
   1065                  pgrp2++;
   \   00000022   0x321C             ADDS     R2,R2,#+28
   1066              }
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \                     ??OS_FlagInit_0: (+1)
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   0x2804             CMP      R0,#+4
   \   0000002A   0xDBF2             BLT.N    ??OS_FlagInit_1
   1067              pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   1068              pgrp1->OSFlagWaitList = (void *)0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6048             STR      R0,[R1, #+4]
   1069          #if OS_FLAG_NAME_SIZE > 1
   1070              pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
   \   00000034   0x203F             MOVS     R0,#+63
   \   00000036   0x7288             STRB     R0,[R1, #+10]
   1071              pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x72C8             STRB     R0,[R1, #+11]
   1072          #endif
   1073              OSFlagFreeList        = &OSFlagTbl[0];
   \   0000003C   0x....             LDR.N    R0,??DataTable8_6
   \   0000003E   0x....             LDR.N    R1,??DataTable8_1
   \   00000040   0x6008             STR      R0,[R1, #+0]
   1074          #endif
   1075          }
   \   00000042   0xBD01             POP      {R0,PC}          ;; return
   1076          
   1077          /*$PAGE*/
   1078          /*
   1079          *********************************************************************************************************
   1080          *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
   1081          *
   1082          * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
   1083          *              desired event flag bits have been set.
   1084          *
   1085          * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
   1086          *                            event flag bit(s) to be set.
   1087          *
   1088          *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
   1089          *                            ready-to-run.
   1090          *
   1091          * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
   1092          *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
   1093          *
   1094          * Called by  : OSFlagsPost() OS_FLAG.C
   1095          *
   1096          * Note(s)    : 1) This function assumes that interrupts are disabled.
   1097          *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
   1098          *********************************************************************************************************
   1099          */
   1100          

   \                                 In section .text, align 2, keep-with-next
   1101          static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
   1102          {
   \                     OS_FlagTaskRdy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1103              OS_TCB   *ptcb;
   1104              BOOLEAN   sched;
   1105          
   1106          
   1107              ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   1108              ptcb->OSTCBDly       = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x85D3             STRH     R3,[R2, #+46]
   1109              ptcb->OSTCBFlagsRdy  = flags_rdy;
   \   00000008   0x8591             STRH     R1,[R2, #+44]
   1110              ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
   \   0000000A   0xF892 0x1030      LDRB     R1,[R2, #+48]
   \   0000000E   0xF011 0x01DF      ANDS     R1,R1,#0xDF
   \   00000012   0xF882 0x1030      STRB     R1,[R2, #+48]
   1111              ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xF882 0x1031      STRB     R1,[R2, #+49]
   1112              if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
   \   0000001C   0xF892 0x1030      LDRB     R1,[R2, #+48]
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD113             BNE.N    ??OS_FlagTaskRdy_0
   1113                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
   \   00000024   0x....             LDR.N    R1,??DataTable8_5
   \   00000026   0x7809             LDRB     R1,[R1, #+0]
   \   00000028   0xF892 0x3036      LDRB     R3,[R2, #+54]
   \   0000002C   0x4319             ORRS     R1,R3,R1
   \   0000002E   0x....             LDR.N    R3,??DataTable8_5
   \   00000030   0x7019             STRB     R1,[R3, #+0]
   1114                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00000032   0x....             LDR.N    R1,??DataTable8_4
   \   00000034   0xF892 0x3034      LDRB     R3,[R2, #+52]
   \   00000038   0x5C59             LDRB     R1,[R3, R1]
   \   0000003A   0xF892 0x3035      LDRB     R3,[R2, #+53]
   \   0000003E   0x4319             ORRS     R1,R3,R1
   \   00000040   0x....             LDR.N    R3,??DataTable8_4
   \   00000042   0xF892 0x2034      LDRB     R2,[R2, #+52]
   \   00000046   0x54D1             STRB     R1,[R2, R3]
   1115                  sched                   = OS_TRUE;
   \   00000048   0x2401             MOVS     R4,#+1
   \   0000004A   0xE000             B.N      ??OS_FlagTaskRdy_1
   1116              } else {
   1117                  sched                   = OS_FALSE;
   \                     ??OS_FlagTaskRdy_0: (+1)
   \   0000004C   0x2400             MOVS     R4,#+0
   1118              }
   1119              OS_FlagUnlink(pnode);
   \                     ??OS_FlagTaskRdy_1: (+1)
   \   0000004E   0x.... 0x....      BL       OS_FlagUnlink
   1120              return (sched);
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
   1121          }
   1122          
   1123          /*$PAGE*/
   1124          /*
   1125          *********************************************************************************************************
   1126          *                                  UNLINK EVENT FLAG NODE FROM WAITING LIST
   1127          *
   1128          * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
   1129          *              list of tasks waiting for the event flag.
   1130          *
   1131          * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
   1132          *                            event flag bit(s) to be set.
   1133          *
   1134          * Returns    : none
   1135          *
   1136          * Called by  : OS_FlagTaskRdy() OS_FLAG.C
   1137          *              OSFlagPend()     OS_FLAG.C
   1138          *              OSTaskDel()      OS_TASK.C
   1139          *
   1140          * Note(s)    : 1) This function assumes that interrupts are disabled.
   1141          *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
   1142          *********************************************************************************************************
   1143          */
   1144          

   \                                 In section .text, align 2, keep-with-next
   1145          void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
   1146          {
   1147          #if OS_TASK_DEL_EN > 0
   1148              OS_TCB       *ptcb;
   1149          #endif
   1150              OS_FLAG_GRP  *pgrp;
   1151              OS_FLAG_NODE *pnode_prev;
   1152              OS_FLAG_NODE *pnode_next;
   1153          
   1154          
   1155              pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
   \                     OS_FlagUnlink: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   1156              pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   1157              if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD106             BNE.N    ??OS_FlagUnlink_0
   1158                  pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
   \   00000008   0x68C1             LDR      R1,[R0, #+12]
   1159                  pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   1160                  if (pnode_next != (OS_FLAG_NODE *)0) {
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD006             BEQ.N    ??OS_FlagUnlink_1
   1161                      pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6051             STR      R1,[R2, #+4]
   \   00000014   0xE003             B.N      ??OS_FlagUnlink_1
   1162                  }
   1163              } else {                                                    /* No,  A node somewhere in the list   */
   1164                  pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
   \                     ??OS_FlagUnlink_0: (+1)
   \   00000016   0x600A             STR      R2,[R1, #+0]
   1165                  if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD000             BEQ.N    ??OS_FlagUnlink_1
   1166                      pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
   \   0000001C   0x6051             STR      R1,[R2, #+4]
   1167                  }
   1168              }
   1169          #if OS_TASK_DEL_EN > 0
   1170              ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
   \                     ??OS_FlagUnlink_1: (+1)
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   1171              ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6281             STR      R1,[R0, #+40]
   1172          #endif
   1173          }
   \   00000024   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     OSFlagFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     OSFlagTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     OSFlagTbl+0x1C
   1174          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSFlagAccept
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      16   OSFlagCreate
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      24   OSFlagDel
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_FlagTaskRdy
        24   -> OS_Sched
      24   OSFlagNameGet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
      24   OSFlagNameSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
        24   -> OS_StrLen
      64   OSFlagPend
        64   -> OS_CPU_SR_Restore
        64   -> OS_CPU_SR_Save
        64   -> OS_FlagBlock
        64   -> OS_FlagUnlink
        64   -> OS_Sched
       8   OSFlagPendGetFlagsRdy
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
      24   OSFlagPost
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_FlagTaskRdy
        24   -> OS_Sched
      16   OSFlagQuery
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
       8   OS_FlagBlock
       8   OS_FlagInit
         8   -> OS_MemClr
       8   OS_FlagTaskRdy
         8   -> OS_FlagUnlink
       0   OS_FlagUnlink


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
     270  OSFlagAccept
      94  OSFlagCreate
     236  OSFlagDel
      82  OSFlagNameGet
      96  OSFlagNameSet
     672  OSFlagPend
      24  OSFlagPendGetFlagsRdy
     306  OSFlagPost
      42  OSFlagQuery
     138  OS_FlagBlock
      68  OS_FlagInit
      88  OS_FlagTaskRdy
      38  OS_FlagUnlink

 
 2 186 bytes in section .text
 
 2 186 bytes of CODE memory

Errors: none
Warnings: none
