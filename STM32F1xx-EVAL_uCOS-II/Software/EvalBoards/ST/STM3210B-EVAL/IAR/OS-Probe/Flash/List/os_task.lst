###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.3.8024/W32 for ARM        27/Feb/2018  22:18:59
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\uCOS-II\Source\os_task.c
#    Command line =  
#        "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\uCOS-II\Source\os_task.c"
#        -lCN "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\"
#        -o "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\CPU\ST\STM32\inc\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-CPU\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-LCD\Source\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-LIB\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uCOS-II\Source\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\"
#        -Ol --use_c++_inline
#    List file    =  
#        F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\os_task.lst
#    Object file  =  
#        F:\Study\uCOS\UCOS
#        II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\os_task.o
#
###############################################################################

F:\Study\uCOS\UCOS II\Micrium_STM32F1xx-EVAL_uCOS-II\Micrium\Software\uCOS-II\Source\os_task.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                            TASK MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_TASK.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.86
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          /*$PAGE*/
     29          /*
     30          *********************************************************************************************************
     31          *                                        CHANGE PRIORITY OF A TASK
     32          *
     33          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
     34          *              priority MUST be available.
     35          *
     36          * Arguments  : oldp     is the old priority
     37          *
     38          *              newp     is the new priority
     39          *
     40          * Returns    : OS_ERR_NONE            is the call was successful
     41          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
     42          *                                     (i.e. >= OS_LOWEST_PRIO)
     43          *              OS_ERR_PRIO_EXIST      if the new priority already exist.
     44          *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
     45          *                                     not exist.
     46          *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
     47          *********************************************************************************************************
     48          */
     49          
     50          #if OS_TASK_CHANGE_PRIO_EN > 0

   \                                 In section .text, align 2, keep-with-next
     51          INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
     52          {
   \                     OSTaskChangePrio: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
     53          #if (OS_EVENT_EN)
     54              OS_EVENT  *pevent;
     55          #if (OS_EVENT_MULTI_EN > 0)
     56              OS_EVENT **pevents;
     57          #endif
     58          #endif
     59              OS_TCB    *ptcb;
     60              INT8U      y_new;
     61              INT8U      x_new;
     62              INT8U      y_old;
     63          #if OS_LOWEST_PRIO <= 63
     64              INT8U      bity_new;
     65              INT8U      bitx_new;
     66              INT8U      bity_old;
     67              INT8U      bitx_old;
     68          #else
     69              INT16U     bity_new;
     70              INT16U     bitx_new;
     71              INT16U     bity_old;
     72              INT16U     bitx_old;
     73          #endif
     74          #if OS_CRITICAL_METHOD == 3
     75              OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
   \   00000008   0x2000             MOVS     R0,#+0
     76          #endif
     77          
     78          
     79          /*$PAGE*/
     80          #if OS_ARG_CHK_EN > 0
     81              if (oldprio >= OS_LOWEST_PRIO) {
     82                  if (oldprio != OS_PRIO_SELF) {
     83                      return (OS_ERR_PRIO_INVALID);
     84                  }
     85              }
     86              if (newprio >= OS_LOWEST_PRIO) {
     87                  return (OS_ERR_PRIO_INVALID);
     88              }
     89          #endif
     90              OS_ENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       OS_CPU_SR_Save
     91              if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD003             BEQ.N    ??OSTaskChangePrio_0
     92                  OS_EXIT_CRITICAL();
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Restore
     93                  return (OS_ERR_PRIO_EXIST);
   \   00000020   0x2028             MOVS     R0,#+40
   \   00000022   0xE0E2             B.N      ??OSTaskChangePrio_1
     94              }
     95              if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
   \                     ??OSTaskChangePrio_0: (+1)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2DFF             CMP      R5,#+255
   \   00000028   0xD104             BNE.N    ??OSTaskChangePrio_2
     96                  oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0xF891 0x5032      LDRB     R5,[R1, #+50]
     97              }
     98              ptcb = OSTCBPrioTbl[oldprio];
   \                     ??OSTaskChangePrio_2: (+1)
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0xF851 0x2025      LDR      R2,[R1, R5, LSL #+2]
     99              if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
   \   0000003E   0x2A00             CMP      R2,#+0
   \   00000040   0xD103             BNE.N    ??OSTaskChangePrio_3
    100                  OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
   \   00000042   0x.... 0x....      BL       OS_CPU_SR_Restore
    101                  return (OS_ERR_PRIO);
   \   00000046   0x2029             MOVS     R0,#+41
   \   00000048   0xE0CF             B.N      ??OSTaskChangePrio_1
    102              }
    103              if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
   \                     ??OSTaskChangePrio_3: (+1)
   \   0000004A   0x2A01             CMP      R2,#+1
   \   0000004C   0xD103             BNE.N    ??OSTaskChangePrio_4
    104                  OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
   \   0000004E   0x.... 0x....      BL       OS_CPU_SR_Restore
    105                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000052   0x2043             MOVS     R0,#+67
   \   00000054   0xE0C9             B.N      ??OSTaskChangePrio_1
    106              }
    107          #if OS_LOWEST_PRIO <= 63
    108              y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
   \                     ??OSTaskChangePrio_4: (+1)
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x08E3             LSRS     R3,R4,#+3
    109              x_new                 = (INT8U)(newprio & 0x07);
   \   0000005A   0xF014 0x0607      ANDS     R6,R4,#0x7
    110              bity_new              = (INT8U)(1 << y_new);
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xFA11 0xF703      LSLS     R7,R1,R3
    111              bitx_new              = (INT8U)(1 << x_new);
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0xFA11 0xFC06      LSLS     R12,R1,R6
    112          #else
    113              y_new                 = (INT8U)((newprio >> 4) & 0x0F);
    114              x_new                 = (INT8U)( newprio & 0x0F);
    115              bity_new              = (INT16U)(1 << y_new);
    116              bitx_new              = (INT16U)(1 << x_new);
    117          #endif
    118          
    119              OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x.... 0x....      LDR.W    LR,??DataTable10
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0xF84E 0x1025      STR      R1,[LR, R5, LSL #+2]
    120              OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable10
   \   0000007A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   0xF841 0x2024      STR      R2,[R1, R4, LSL #+2]
    121              y_old                 =  ptcb->OSTCBY;
   \   00000080   0xF892 0x5034      LDRB     R5,[R2, #+52]
    122              bity_old              =  ptcb->OSTCBBitY;
   \   00000084   0xF892 0xE036      LDRB     LR,[R2, #+54]
    123              bitx_old              =  ptcb->OSTCBBitX;
   \   00000088   0xF892 0x8035      LDRB     R8,[R2, #+53]
    124              if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000090   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000092   0x5C69             LDRB     R1,[R5, R1]
   \   00000094   0xEA11 0x0F08      TST      R1,R8
   \   00000098   0xD02C             BEQ.N    ??OSTaskChangePrio_5
    125                   OSRdyTbl[y_old] &= ~bitx_old;
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000009E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A0   0x5C69             LDRB     R1,[R5, R1]
   \   000000A2   0xEA31 0x0108      BICS     R1,R1,R8
   \   000000A6   0x.... 0x....      LDR.W    R9,??DataTable10_2
   \   000000AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AC   0xF805 0x1009      STRB     R1,[R5, R9]
    126                   if (OSRdyTbl[y_old] == 0) {
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000000B4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B6   0x5C69             LDRB     R1,[R5, R1]
   \   000000B8   0x2900             CMP      R1,#+0
   \   000000BA   0xD108             BNE.N    ??OSTaskChangePrio_6
    127                       OSRdyGrp &= ~bity_old;
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   000000C0   0x7809             LDRB     R1,[R1, #+0]
   \   000000C2   0xEA31 0x010E      BICS     R1,R1,LR
   \   000000C6   0x.... 0x....      LDR.W    R9,??DataTable10_3
   \   000000CA   0xF889 0x1000      STRB     R1,[R9, #+0]
    128                   }
    129                   OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
   \                     ??OSTaskChangePrio_6: (+1)
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   000000D2   0x7809             LDRB     R1,[R1, #+0]
   \   000000D4   0x4339             ORRS     R1,R7,R1
   \   000000D6   0x.... 0x....      LDR.W    R9,??DataTable10_3
   \   000000DA   0xF889 0x1000      STRB     R1,[R9, #+0]
    130                   OSRdyTbl[y_new] |= bitx_new;
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000000E2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000E4   0x5C59             LDRB     R1,[R3, R1]
   \   000000E6   0xEA5C 0x0101      ORRS     R1,R12,R1
   \   000000EA   0x.... 0x....      LDR.W    R9,??DataTable10_2
   \   000000EE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000F0   0xF803 0x1009      STRB     R1,[R3, R9]
    131              }
    132          
    133          #if (OS_EVENT_EN)
    134              pevent = ptcb->OSTCBEventPtr;
   \                     ??OSTaskChangePrio_5: (+1)
   \   000000F4   0x69D1             LDR      R1,[R2, #+28]
    135              if (pevent != (OS_EVENT *)0) {
   \   000000F6   0x2900             CMP      R1,#+0
   \   000000F8   0xD02A             BEQ.N    ??OSTaskChangePrio_7
    136                  pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
   \   000000FA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FC   0xEB15 0x0901      ADDS     R9,R5,R1
   \   00000100   0xF899 0x900B      LDRB     R9,[R9, #+11]
   \   00000104   0xEA39 0x0908      BICS     R9,R9,R8
   \   00000108   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010A   0xEB15 0x0A01      ADDS     R10,R5,R1
   \   0000010E   0xF88A 0x900B      STRB     R9,[R10, #+11]
    137                  if (pevent->OSEventTbl[y_old] == 0) {
   \   00000112   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000114   0xEB15 0x0901      ADDS     R9,R5,R1
   \   00000118   0xF899 0x900B      LDRB     R9,[R9, #+11]
   \   0000011C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000120   0xD105             BNE.N    ??OSTaskChangePrio_8
    138                      pevent->OSEventGrp    &= ~bity_old;
   \   00000122   0xF891 0x900A      LDRB     R9,[R1, #+10]
   \   00000126   0xEA39 0x090E      BICS     R9,R9,LR
   \   0000012A   0xF881 0x900A      STRB     R9,[R1, #+10]
    139                  }
    140                  pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
   \                     ??OSTaskChangePrio_8: (+1)
   \   0000012E   0xF891 0x900A      LDRB     R9,[R1, #+10]
   \   00000132   0xEA57 0x0909      ORRS     R9,R7,R9
   \   00000136   0xF881 0x900A      STRB     R9,[R1, #+10]
    141                  pevent->OSEventTbl[y_new] |= bitx_new;
   \   0000013A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000013C   0xEB13 0x0901      ADDS     R9,R3,R1
   \   00000140   0xF899 0x900B      LDRB     R9,[R9, #+11]
   \   00000144   0xEA5C 0x0909      ORRS     R9,R12,R9
   \   00000148   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000014A   0x1859             ADDS     R1,R3,R1
   \   0000014C   0xF881 0x900B      STRB     R9,[R1, #+11]
    142              }
    143          #if (OS_EVENT_MULTI_EN > 0)
    144              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
   \                     ??OSTaskChangePrio_7: (+1)
   \   00000150   0x6A11             LDR      R1,[R2, #+32]
   \   00000152   0x2900             CMP      R1,#+0
   \   00000154   0xD035             BEQ.N    ??OSTaskChangePrio_9
    145                  pevents =  ptcb->OSTCBEventMultiPtr;
   \   00000156   0xF8D2 0x9020      LDR      R9,[R2, #+32]
    146                  pevent  = *pevents;
   \   0000015A   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   0000015E   0xE02E             B.N      ??OSTaskChangePrio_10
    147                  while (pevent != (OS_EVENT *)0) {
    148                      pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
   \                     ??OSTaskChangePrio_11: (+1)
   \   00000160   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000162   0xEB15 0x0A01      ADDS     R10,R5,R1
   \   00000166   0xF89A 0xA00B      LDRB     R10,[R10, #+11]
   \   0000016A   0xEA3A 0x0A08      BICS     R10,R10,R8
   \   0000016E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000170   0xEB15 0x0B01      ADDS     R11,R5,R1
   \   00000174   0xF88B 0xA00B      STRB     R10,[R11, #+11]
    149                      if (pevent->OSEventTbl[y_old] == 0) {
   \   00000178   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000017A   0xEB15 0x0A01      ADDS     R10,R5,R1
   \   0000017E   0xF89A 0xA00B      LDRB     R10,[R10, #+11]
   \   00000182   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000186   0xD105             BNE.N    ??OSTaskChangePrio_12
    150                          pevent->OSEventGrp    &= ~bity_old;
   \   00000188   0xF891 0xA00A      LDRB     R10,[R1, #+10]
   \   0000018C   0xEA3A 0x0A0E      BICS     R10,R10,LR
   \   00000190   0xF881 0xA00A      STRB     R10,[R1, #+10]
    151                      }
    152                      pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
   \                     ??OSTaskChangePrio_12: (+1)
   \   00000194   0xF891 0xA00A      LDRB     R10,[R1, #+10]
   \   00000198   0xEA57 0x0A0A      ORRS     R10,R7,R10
   \   0000019C   0xF881 0xA00A      STRB     R10,[R1, #+10]
    153                      pevent->OSEventTbl[y_new] |= bitx_new;
   \   000001A0   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001A2   0xEB13 0x0A01      ADDS     R10,R3,R1
   \   000001A6   0xF89A 0xA00B      LDRB     R10,[R10, #+11]
   \   000001AA   0xEA5C 0x0A0A      ORRS     R10,R12,R10
   \   000001AE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001B0   0x1859             ADDS     R1,R3,R1
   \   000001B2   0xF881 0xA00B      STRB     R10,[R1, #+11]
    154                      pevents++;
   \   000001B6   0xF119 0x0904      ADDS     R9,R9,#+4
    155                      pevent                     = *pevents;
   \   000001BA   0xF8D9 0x1000      LDR      R1,[R9, #+0]
    156                  }
   \                     ??OSTaskChangePrio_10: (+1)
   \   000001BE   0x2900             CMP      R1,#+0
   \   000001C0   0xD1CE             BNE.N    ??OSTaskChangePrio_11
    157              }
    158          #endif
    159          #endif
    160          
    161              ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
   \                     ??OSTaskChangePrio_9: (+1)
   \   000001C2   0xF882 0x4032      STRB     R4,[R2, #+50]
    162              ptcb->OSTCBY    = y_new;
   \   000001C6   0xF882 0x3034      STRB     R3,[R2, #+52]
    163              ptcb->OSTCBX    = x_new;
   \   000001CA   0xF882 0x6033      STRB     R6,[R2, #+51]
    164              ptcb->OSTCBBitY = bity_new;
   \   000001CE   0xF882 0x7036      STRB     R7,[R2, #+54]
    165              ptcb->OSTCBBitX = bitx_new;
   \   000001D2   0xF882 0xC035      STRB     R12,[R2, #+53]
    166              OS_EXIT_CRITICAL();
   \   000001D6   0x.... 0x....      BL       OS_CPU_SR_Restore
    167              if (OSRunning == OS_TRUE) {
   \   000001DA   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   000001DE   0x7800             LDRB     R0,[R0, #+0]
   \   000001E0   0x2801             CMP      R0,#+1
   \   000001E2   0xD101             BNE.N    ??OSTaskChangePrio_13
    168                  OS_Sched();                                         /* Find new highest priority task          */
   \   000001E4   0x.... 0x....      BL       OS_Sched
    169              }
    170              return (OS_ERR_NONE);
   \                     ??OSTaskChangePrio_13: (+1)
   \   000001E8   0x2000             MOVS     R0,#+0
   \                     ??OSTaskChangePrio_1: (+1)
   \   000001EA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    171          }
    172          #endif
    173          /*$PAGE*/
    174          /*
    175          *********************************************************************************************************
    176          *                                            CREATE A TASK
    177          *
    178          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
    179          *              be created prior to the start of multitasking or by a running task.  A task cannot be
    180          *              created by an ISR.
    181          *
    182          * Arguments  : task     is a pointer to the task's code
    183          *
    184          *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
    185          *                       the task when the task first executes.  Where the task is concerned it thinks
    186          *                       it was invoked and passed the argument 'p_arg' as follows:
    187          *
    188          *                           void Task (void *p_arg)
    189          *                           {
    190          *                               for (;;) {
    191          *                                   Task code;
    192          *                               }
    193          *                           }
    194          *
    195          *              ptos     is a pointer to the task's top of stack.  If the configuration constant
    196          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    197          *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
    198          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
    199          *                       lowest memory location of the stack and the stack will grow with increasing
    200          *                       memory locations.
    201          *
    202          *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
    203          *                       lower the number, the higher the priority.
    204          *
    205          * Returns    : OS_ERR_NONE             if the function was successful.
    206          *              OS_PRIO_EXIT            if the task priority already exist
    207          *                                      (each task MUST have a unique priority).
    208          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    209          *                                      (i.e. >= OS_LOWEST_PRIO)
    210          *              OS_ERR_TASK_CREATE_ISR  if you tried to create a task from an ISR.
    211          *********************************************************************************************************
    212          */
    213          
    214          #if OS_TASK_CREATE_EN > 0

   \                                 In section .text, align 2, keep-with-next
    215          INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
    216          {
   \                     OSTaskCreate: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x001C             MOVS     R4,R3
    217              OS_STK    *psp;
    218              INT8U      err;
    219          #if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    220              OS_CPU_SR  cpu_sr = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
    221          #endif
    222          
    223          
    224          
    225          #if OS_ARG_CHK_EN > 0
    226              if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
    227                  return (OS_ERR_PRIO_INVALID);
    228              }
    229          #endif
    230              OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
    231              if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD003             BEQ.N    ??OSTaskCreate_0
    232                  OS_EXIT_CRITICAL();
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Restore
    233                  return (OS_ERR_TASK_CREATE_ISR);
   \   0000001E   0x203C             MOVS     R0,#+60
   \   00000020   0xE03D             B.N      ??OSTaskCreate_1
    234              }
    235              if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
   \                     ??OSTaskCreate_0: (+1)
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD133             BNE.N    ??OSTaskCreate_2
    236                  OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable10
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0xF842 0x1024      STR      R1,[R2, R4, LSL #+2]
    237                                                       /* ... the same thing until task is created.              */
    238                  OS_EXIT_CRITICAL();
   \   0000003C   0x.... 0x....      BL       OS_CPU_SR_Restore
    239                  psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
   \   00000040   0x2300             MOVS     R3,#+0
   \   00000042   0x003A             MOVS     R2,R7
   \   00000044   0x0031             MOVS     R1,R6
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       OSTaskStkInit
   \   0000004C   0x0001             MOVS     R1,R0
    240                  err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x9002             STR      R0,[SP, #+8]
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x9001             STR      R0,[SP, #+4]
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x9000             STR      R0,[SP, #+0]
   \   0000005A   0x2300             MOVS     R3,#+0
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x.... 0x....      BL       OS_TCBInit
   \   00000066   0x0005             MOVS     R5,R0
    241                  if (err == OS_ERR_NONE) {
   \   00000068   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0xD107             BNE.N    ??OSTaskCreate_3
    242                      if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000072   0x7800             LDRB     R0,[R0, #+0]
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD10C             BNE.N    ??OSTaskCreate_4
    243                          OS_Sched();
   \   00000078   0x.... 0x....      BL       OS_Sched
   \   0000007C   0xE009             B.N      ??OSTaskCreate_4
    244                      }
    245                  } else {
    246                      OS_ENTER_CRITICAL();
   \                     ??OSTaskCreate_3: (+1)
   \   0000007E   0x.... 0x....      BL       OS_CPU_SR_Save
    247                      OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable10
   \   00000088   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   0xF842 0x1024      STR      R1,[R2, R4, LSL #+2]
    248                      OS_EXIT_CRITICAL();
   \   0000008E   0x.... 0x....      BL       OS_CPU_SR_Restore
    249                  }
    250                  return (err);
   \                     ??OSTaskCreate_4: (+1)
   \   00000092   0x0028             MOVS     R0,R5
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0xE002             B.N      ??OSTaskCreate_1
    251              }
    252              OS_EXIT_CRITICAL();
   \                     ??OSTaskCreate_2: (+1)
   \   00000098   0x.... 0x....      BL       OS_CPU_SR_Restore
    253              return (OS_ERR_PRIO_EXIST);
   \   0000009C   0x2028             MOVS     R0,#+40
   \                     ??OSTaskCreate_1: (+1)
   \   0000009E   0xBDFE             POP      {R1-R7,PC}       ;; return
    254          }
    255          #endif
    256          /*$PAGE*/
    257          /*
    258          *********************************************************************************************************
    259          *                                     CREATE A TASK (Extended Version)
    260          *
    261          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
    262          *              be created prior to the start of multitasking or by a running task.  A task cannot be
    263          *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
    264          *              additional information about a task to be specified.
    265          *
    266          * Arguments  : task      is a pointer to the task's code
    267          *
    268          *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
    269          *                        the task when the task first executes.  Where the task is concerned it thinks
    270          *                        it was invoked and passed the argument 'p_arg' as follows:
    271          *
    272          *                            void Task (void *p_arg)
    273          *                            {
    274          *                                for (;;) {
    275          *                                    Task code;
    276          *                                }
    277          *                            }
    278          *
    279          *              ptos      is a pointer to the task's top of stack.  If the configuration constant
    280          *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    281          *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
    282          *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
    283          *                        lowest memory location of the stack and the stack will grow with increasing
    284          *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
    285          *
    286          *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
    287          *                        lower the number, the higher the priority.
    288          *
    289          *              id        is the task's ID (0..65535)
    290          *
    291          *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
    292          *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    293          *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
    294          *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
    295          *                        HIGHEST memory location of the stack and the stack will grow with increasing
    296          *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
    297          *
    298          *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
    299          *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
    300          *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
    301          *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
    302          *                        available on the stack.
    303          *
    304          *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
    305          *                        For example, this user memory can hold the contents of floating-point registers
    306          *                        during a context switch, the time each task takes to execute, the number of times
    307          *                        the task has been switched-in, etc.
    308          *
    309          *              opt       contains additional information (or options) about the behavior of the task.  The
    310          *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
    311          *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
    312          *
    313          *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
    314          *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
    315          *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
    316          *                                                 during a context switch.
    317          *
    318          * Returns    : OS_ERR_NONE             if the function was successful.
    319          *              OS_PRIO_EXIT            if the task priority already exist
    320          *                                      (each task MUST have a unique priority).
    321          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    322          *                                      (i.e. > OS_LOWEST_PRIO)
    323          *              OS_ERR_TASK_CREATE_ISR  if you tried to create a task from an ISR.
    324          *********************************************************************************************************
    325          */
    326          /*$PAGE*/
    327          #if OS_TASK_CREATE_EXT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    328          INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
    329                                  void    *p_arg,
    330                                  OS_STK  *ptos,
    331                                  INT8U    prio,
    332                                  INT16U   id,
    333                                  OS_STK  *pbos,
    334                                  INT32U   stk_size,
    335                                  void    *pext,
    336                                  INT16U   opt)
    337          {
   \                     OSTaskCreateExt: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x000F             MOVS     R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x001D             MOVS     R5,R3
    338              OS_STK    *psp;
    339              INT8U      err;
    340          #if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    341              OS_CPU_SR  cpu_sr = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
    342          #endif
    343          
    344          
    345          
    346          #if OS_ARG_CHK_EN > 0
    347              if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
    348                  return (OS_ERR_PRIO_INVALID);
    349              }
    350          #endif
    351              OS_ENTER_CRITICAL();
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
    352              if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD003             BEQ.N    ??OSTaskCreateExt_0
    353                  OS_EXIT_CRITICAL();
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Restore
    354                  return (OS_ERR_TASK_CREATE_ISR);
   \   00000022   0x203C             MOVS     R0,#+60
   \   00000024   0xE049             B.N      ??OSTaskCreateExt_1
    355              }
    356              if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
   \                     ??OSTaskCreateExt_0: (+1)
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable10
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD13F             BNE.N    ??OSTaskCreateExt_2
    357                  OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x.... 0x....      LDR.W    R2,??DataTable10
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0xF842 0x1025      STR      R1,[R2, R5, LSL #+2]
    358                                                       /* ... the same thing until task is created.              */
    359                  OS_EXIT_CRITICAL();
   \   00000040   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000044   0xF8DD 0x9034      LDR      R9,[SP, #+52]
   \   00000048   0xF8DD 0xA038      LDR      R10,[SP, #+56]
   \   0000004C   0x9C10             LDR      R4,[SP, #+64]
    360          
    361          #if (OS_TASK_STAT_STK_CHK_EN > 0)
    362                  OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
   \   0000004E   0x0022             MOVS     R2,R4
   \   00000050   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000052   0x4651             MOV      R1,R10
   \   00000054   0x4648             MOV      R0,R9
   \   00000056   0x.... 0x....      BL       OS_TaskStkClr
    363          #endif
    364          
    365                  psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
   \   0000005A   0x0023             MOVS     R3,R4
   \   0000005C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000005E   0x4642             MOV      R2,R8
   \   00000060   0x0039             MOVS     R1,R7
   \   00000062   0x0030             MOVS     R0,R6
   \   00000064   0x.... 0x....      BL       OSTaskStkInit
   \   00000068   0x0001             MOVS     R1,R0
    366                  err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
   \   0000006A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000006C   0x9402             STR      R4,[SP, #+8]
   \   0000006E   0x980F             LDR      R0,[SP, #+60]
   \   00000070   0x9001             STR      R0,[SP, #+4]
   \   00000072   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   00000076   0x9B0C             LDR      R3,[SP, #+48]
   \   00000078   0x464A             MOV      R2,R9
   \   0000007A   0x0028             MOVS     R0,R5
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x.... 0x....      BL       OS_TCBInit
   \   00000082   0x0004             MOVS     R4,R0
    367                  if (err == OS_ERR_NONE) {
   \   00000084   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000086   0x2C00             CMP      R4,#+0
   \   00000088   0xD107             BNE.N    ??OSTaskCreateExt_3
    368                      if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD10C             BNE.N    ??OSTaskCreateExt_4
    369                          OS_Sched();
   \   00000094   0x.... 0x....      BL       OS_Sched
   \   00000098   0xE009             B.N      ??OSTaskCreateExt_4
    370                      }
    371                  } else {
    372                      OS_ENTER_CRITICAL();
   \                     ??OSTaskCreateExt_3: (+1)
   \   0000009A   0x.... 0x....      BL       OS_CPU_SR_Save
    373                      OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
   \   0000009E   0x2100             MOVS     R1,#+0
   \   000000A0   0x.... 0x....      LDR.W    R2,??DataTable10
   \   000000A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A6   0xF842 0x1025      STR      R1,[R2, R5, LSL #+2]
    374                      OS_EXIT_CRITICAL();
   \   000000AA   0x.... 0x....      BL       OS_CPU_SR_Restore
    375                  }
    376                  return (err);
   \                     ??OSTaskCreateExt_4: (+1)
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0xE002             B.N      ??OSTaskCreateExt_1
    377              }
    378              OS_EXIT_CRITICAL();
   \                     ??OSTaskCreateExt_2: (+1)
   \   000000B4   0x.... 0x....      BL       OS_CPU_SR_Restore
    379              return (OS_ERR_PRIO_EXIST);
   \   000000B8   0x2028             MOVS     R0,#+40
   \                     ??OSTaskCreateExt_1: (+1)
   \   000000BA   0xB004             ADD      SP,SP,#+16
   \   000000BC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    380          }
    381          #endif
    382          /*$PAGE*/
    383          /*
    384          *********************************************************************************************************
    385          *                                            DELETE A TASK
    386          *
    387          * Description: This function allows you to delete a task.  The calling task can delete itself by
    388          *              its own priority number.  The deleted task is returned to the dormant state and can be
    389          *              re-activated by creating the deleted task again.
    390          *
    391          * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitely delete
    392          *                      the current task without knowing its priority level by setting 'prio' to
    393          *                      OS_PRIO_SELF.
    394          *
    395          * Returns    : OS_ERR_NONE             if the call is successful
    396          *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
    397          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    398          *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    399          *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.   
    400          *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
    401          *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
    402          *
    403          * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
    404          *                    a) by making it not ready
    405          *                    b) by removing it from any wait lists
    406          *                    c) by preventing OSTimeTick() from making the task ready to run.
    407          *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
    408          *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
    409          *                 the next instruction following the enable interrupt instruction is ignored.
    410          *              3) An ISR cannot delete a task.
    411          *              4) The lock nesting counter is incremented because, for a brief instant, if the current
    412          *                 task is being deleted, the current task would not be able to be rescheduled because it
    413          *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
    414          *                 from being schedule.  This means that an ISR would return to the current task which is
    415          *                 being deleted.  The rest of the deletion would thus be able to be completed.
    416          *********************************************************************************************************
    417          */
    418          
    419          #if OS_TASK_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    420          INT8U  OSTaskDel (INT8U prio)
    421          {
   \                     OSTaskDel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    422          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    423              OS_FLAG_NODE *pnode;
    424          #endif
    425              OS_TCB       *ptcb;
    426          #if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    427              OS_CPU_SR     cpu_sr = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    428          #endif
    429          
    430          
    431          
    432              if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??OSTaskDel_0
    433                  return (OS_ERR_TASK_DEL_ISR);
   \   00000010   0x2040             MOVS     R0,#+64
   \   00000012   0xE0B3             B.N      ??OSTaskDel_1
    434              }
    435              if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
   \                     ??OSTaskDel_0: (+1)
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C1F             CMP      R4,#+31
   \   00000018   0xD101             BNE.N    ??OSTaskDel_2
    436                  return (OS_ERR_TASK_DEL_IDLE);
   \   0000001A   0x203E             MOVS     R0,#+62
   \   0000001C   0xE0AE             B.N      ??OSTaskDel_1
    437              }
    438          #if OS_ARG_CHK_EN > 0
    439              if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
    440                  if (prio != OS_PRIO_SELF) {
    441                      return (OS_ERR_PRIO_INVALID);
    442                  }
    443              }
    444          #endif
    445          
    446          /*$PAGE*/
    447              OS_ENTER_CRITICAL();
   \                     ??OSTaskDel_2: (+1)
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000022   0x0005             MOVS     R5,R0
    448              if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2CFF             CMP      R4,#+255
   \   00000028   0xD104             BNE.N    ??OSTaskDel_3
    449                  prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF890 0x4032      LDRB     R4,[R0, #+50]
    450              }
    451              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskDel_3: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0xF850 0x6024      LDR      R6,[R0, R4, LSL #+2]
    452              if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
   \   0000003E   0x2E00             CMP      R6,#+0
   \   00000040   0xD104             BNE.N    ??OSTaskDel_4
    453                  OS_EXIT_CRITICAL();
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0x.... 0x....      BL       OS_CPU_SR_Restore
    454                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000048   0x2043             MOVS     R0,#+67
   \   0000004A   0xE097             B.N      ??OSTaskDel_1
    455              }
    456              if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
   \                     ??OSTaskDel_4: (+1)
   \   0000004C   0x2E01             CMP      R6,#+1
   \   0000004E   0xD104             BNE.N    ??OSTaskDel_5
    457                  OS_EXIT_CRITICAL();
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0x.... 0x....      BL       OS_CPU_SR_Restore
    458                  return (OS_ERR_TASK_DEL);
   \   00000056   0x203D             MOVS     R0,#+61
   \   00000058   0xE090             B.N      ??OSTaskDel_1
    459              }
    460          
    461              OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
   \                     ??OSTaskDel_5: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000005E   0xF896 0x1034      LDRB     R1,[R6, #+52]
   \   00000062   0x5C08             LDRB     R0,[R1, R0]
   \   00000064   0xF896 0x1035      LDRB     R1,[R6, #+53]
   \   00000068   0x4388             BICS     R0,R0,R1
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000006E   0xF896 0x2034      LDRB     R2,[R6, #+52]
   \   00000072   0x5450             STRB     R0,[R2, R1]
    462              if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000078   0xF896 0x1034      LDRB     R1,[R6, #+52]
   \   0000007C   0x5C08             LDRB     R0,[R1, R0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD108             BNE.N    ??OSTaskDel_6
    463                  OSRdyGrp           &= ~ptcb->OSTCBBitY;
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0xF896 0x1036      LDRB     R1,[R6, #+54]
   \   0000008C   0x4388             BICS     R0,R0,R1
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    464              }
    465              
    466          #if (OS_EVENT_EN)
    467              if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
   \                     ??OSTaskDel_6: (+1)
   \   00000094   0x69F0             LDR      R0,[R6, #+28]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD003             BEQ.N    ??OSTaskDel_7
    468                  OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
   \   0000009A   0x69F1             LDR      R1,[R6, #+28]
   \   0000009C   0x0030             MOVS     R0,R6
   \   0000009E   0x.... 0x....      BL       OS_EventTaskRemove
    469              }
    470          #if (OS_EVENT_MULTI_EN > 0)
    471              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
   \                     ??OSTaskDel_7: (+1)
   \   000000A2   0x6A30             LDR      R0,[R6, #+32]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD003             BEQ.N    ??OSTaskDel_8
    472                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   \   000000A8   0x6A31             LDR      R1,[R6, #+32]
   \   000000AA   0x0030             MOVS     R0,R6
   \   000000AC   0x.... 0x....      BL       OS_EventTaskRemoveMulti
    473              }
    474          #endif
    475          #endif
    476          
    477          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    478              pnode = ptcb->OSTCBFlagNode;
   \                     ??OSTaskDel_8: (+1)
   \   000000B0   0x6AB0             LDR      R0,[R6, #+40]
    479              if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD001             BEQ.N    ??OSTaskDel_9
    480                  OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
   \   000000B6   0x.... 0x....      BL       OS_FlagUnlink
    481              }
    482          #endif
    483          
    484              ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
   \                     ??OSTaskDel_9: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x85F0             STRH     R0,[R6, #+46]
    485              ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xF886 0x0030      STRB     R0,[R6, #+48]
    486              ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xF886 0x0031      STRB     R0,[R6, #+49]
    487              if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   000000CE   0x7800             LDRB     R0,[R0, #+0]
   \   000000D0   0x28FF             CMP      R0,#+255
   \   000000D2   0xD006             BEQ.N    ??OSTaskDel_10
    488                  OSLockNesting++;
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x1C40             ADDS     R0,R0,#+1
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable10_6
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
    489              }
    490              OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
   \                     ??OSTaskDel_10: (+1)
   \   000000E2   0x0028             MOVS     R0,R5
   \   000000E4   0x.... 0x....      BL       OS_CPU_SR_Restore
    491              OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
   \   000000E8   0x.... 0x....      BL       OS_Dummy
    492              OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
   \   000000EC   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000000F0   0x0005             MOVS     R5,R0
    493              if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD006             BEQ.N    ??OSTaskDel_11
    494                  OSLockNesting--;
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   00000100   0x7800             LDRB     R0,[R0, #+0]
   \   00000102   0x1E40             SUBS     R0,R0,#+1
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable10_6
   \   00000108   0x7008             STRB     R0,[R1, #+0]
    495              }
    496              OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
   \                     ??OSTaskDel_11: (+1)
   \   0000010A   0x0030             MOVS     R0,R6
   \   0000010C   0x.... 0x....      BL       OSTaskDelHook
    497              OSTaskCtr--;                                        /* One less task being managed                 */
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable10_7
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0x1E40             SUBS     R0,R0,#+1
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable10_7
   \   0000011C   0x7008             STRB     R0,[R1, #+0]
    498              OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000124   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000126   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
    499              if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
   \   0000012A   0x69B0             LDR      R0,[R6, #+24]
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD107             BNE.N    ??OSTaskDel_12
    500                  ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0x6971             LDR      R1,[R6, #+20]
   \   00000134   0x6188             STR      R0,[R1, #+24]
    501                  OSTCBList                  = ptcb->OSTCBNext;
   \   00000136   0x6970             LDR      R0,[R6, #+20]
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable10_8
   \   0000013C   0x6008             STR      R0,[R1, #+0]
   \   0000013E   0xE005             B.N      ??OSTaskDel_13
    502              } else {
    503                  ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
   \                     ??OSTaskDel_12: (+1)
   \   00000140   0x6970             LDR      R0,[R6, #+20]
   \   00000142   0x69B1             LDR      R1,[R6, #+24]
   \   00000144   0x6148             STR      R0,[R1, #+20]
    504                  ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
   \   00000146   0x69B0             LDR      R0,[R6, #+24]
   \   00000148   0x6971             LDR      R1,[R6, #+20]
   \   0000014A   0x6188             STR      R0,[R1, #+24]
    505              }
    506              ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
   \                     ??OSTaskDel_13: (+1)
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable10_9
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x6170             STR      R0,[R6, #+20]
    507              OSTCBFreeList     = ptcb;
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable10_9
   \   00000158   0x6006             STR      R6,[R0, #+0]
    508          #if OS_TASK_NAME_SIZE > 1
    509              ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
   \   0000015A   0x203F             MOVS     R0,#+63
   \   0000015C   0xF886 0x004C      STRB     R0,[R6, #+76]
    510              ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0xF886 0x004D      STRB     R0,[R6, #+77]
    511          #endif
    512              OS_EXIT_CRITICAL();
   \   00000166   0x0028             MOVS     R0,R5
   \   00000168   0x.... 0x....      BL       OS_CPU_SR_Restore
    513              if (OSRunning == OS_TRUE) {
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000170   0x7800             LDRB     R0,[R0, #+0]
   \   00000172   0x2801             CMP      R0,#+1
   \   00000174   0xD101             BNE.N    ??OSTaskDel_14
    514                  OS_Sched();                                     /* Find new highest priority task              */
   \   00000176   0x.... 0x....      BL       OS_Sched
    515              }
    516              return (OS_ERR_NONE);
   \                     ??OSTaskDel_14: (+1)
   \   0000017A   0x2000             MOVS     R0,#+0
   \                     ??OSTaskDel_1: (+1)
   \   0000017C   0xBD70             POP      {R4-R6,PC}       ;; return
    517          }
    518          #endif
    519          /*$PAGE*/
    520          /*
    521          *********************************************************************************************************
    522          *                                    REQUEST THAT A TASK DELETE ITSELF
    523          *
    524          * Description: This function is used to:
    525          *                   a) notify a task to delete itself.
    526          *                   b) to see if a task requested that the current task delete itself.
    527          *              This function is a little tricky to understand.  Basically, you have a task that needs
    528          *              to be deleted however, this task has resources that it has allocated (memory buffers,
    529          *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
    530          *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
    531          *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
    532          *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
    533          *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
    534          *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
    535          *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
    536          *              this:
    537          *
    538          *                   void Task(void *p_arg)
    539          *                   {
    540          *                       .
    541          *                       .
    542          *                       while (1) {
    543          *                           OSTimeDly(1);
    544          *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
    545          *                               Release any owned resources;
    546          *                               De-allocate any dynamic memory;
    547          *                               OSTaskDel(OS_PRIO_SELF);
    548          *                           }
    549          *                       }
    550          *                   }
    551          *
    552          * Arguments  : prio    is the priority of the task to request the delete from
    553          *
    554          * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
    555          *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
    556          *                                     the request has been executed.
    557          *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
    558          *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
    559          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
    560          *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    561          *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
    562          *                                     deleted.
    563          *********************************************************************************************************
    564          */
    565          /*$PAGE*/
    566          #if OS_TASK_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    567          INT8U  OSTaskDelReq (INT8U prio)
    568          {
   \                     OSTaskDelReq: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    569              INT8U      stat;
    570              OS_TCB    *ptcb;
    571          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    572              OS_CPU_SR  cpu_sr = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    573          #endif
    574          
    575          
    576          
    577              if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C1F             CMP      R4,#+31
   \   0000000A   0xD101             BNE.N    ??OSTaskDelReq_0
    578                  return (OS_ERR_TASK_DEL_IDLE);
   \   0000000C   0x203E             MOVS     R0,#+62
   \   0000000E   0xE025             B.N      ??OSTaskDelReq_1
    579              }
    580          #if OS_ARG_CHK_EN > 0
    581              if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
    582                  if (prio != OS_PRIO_SELF) {
    583                      return (OS_ERR_PRIO_INVALID);
    584                  }
    585              }
    586          #endif
    587              if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
   \                     ??OSTaskDelReq_0: (+1)
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2CFF             CMP      R4,#+255
   \   00000014   0xD10A             BNE.N    ??OSTaskDelReq_2
    588                  OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
    589                  stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
   \   0000001A   0x....             LDR.N    R1,??DataTable10_1
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0xF891 0x4037      LDRB     R4,[R1, #+55]
    590                  OS_EXIT_CRITICAL();
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Restore
    591                  return (stat);
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xE017             B.N      ??OSTaskDelReq_1
    592              }
    593              OS_ENTER_CRITICAL();
   \                     ??OSTaskDelReq_2: (+1)
   \   0000002C   0x.... 0x....      BL       OS_CPU_SR_Save
    594              ptcb = OSTCBPrioTbl[prio];
   \   00000030   0x....             LDR.N    R1,??DataTable10
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
    595              if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD103             BNE.N    ??OSTaskDelReq_3
    596                  OS_EXIT_CRITICAL();
   \   0000003C   0x.... 0x....      BL       OS_CPU_SR_Restore
    597                  return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
   \   00000040   0x2043             MOVS     R0,#+67
   \   00000042   0xE00B             B.N      ??OSTaskDelReq_1
    598              }
    599              if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
   \                     ??OSTaskDelReq_3: (+1)
   \   00000044   0x2901             CMP      R1,#+1
   \   00000046   0xD103             BNE.N    ??OSTaskDelReq_4
    600                  OS_EXIT_CRITICAL();
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    601                  return (OS_ERR_TASK_DEL);
   \   0000004C   0x203D             MOVS     R0,#+61
   \   0000004E   0xE005             B.N      ??OSTaskDelReq_1
    602              }
    603              ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
   \                     ??OSTaskDelReq_4: (+1)
   \   00000050   0x223F             MOVS     R2,#+63
   \   00000052   0xF881 0x2037      STRB     R2,[R1, #+55]
    604              OS_EXIT_CRITICAL();
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
    605              return (OS_ERR_NONE);
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??OSTaskDelReq_1: (+1)
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    606          }
    607          #endif
    608          /*$PAGE*/
    609          /*
    610          *********************************************************************************************************
    611          *                                        GET THE NAME OF A TASK
    612          *
    613          * Description: This function is called to obtain the name of a task.
    614          *
    615          * Arguments  : prio      is the priority of the task that you want to obtain the name from.
    616          *
    617          *              pname     is a pointer to an ASCII string that will receive the name of the task.  The
    618          *                        string must be able to hold at least OS_TASK_NAME_SIZE characters.
    619          *
    620          *              perr      is a pointer to an error code that can contain one of the following values:
    621          *
    622          *                        OS_ERR_NONE                if the requested task is resumed
    623          *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
    624          *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
    625          *                                                   A higher value than the idle task or not OS_PRIO_SELF.
    626          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    627          *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
    628          *                        
    629          *
    630          * Returns    : The length of the string or 0 if the task does not exist.
    631          *********************************************************************************************************
    632          */
    633          
    634          #if OS_TASK_NAME_SIZE > 1

   \                                 In section .text, align 2, keep-with-next
    635          INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
    636          {
   \                     OSTaskNameGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0014             MOVS     R4,R2
    637              OS_TCB    *ptcb;
    638              INT8U      len;
    639          #if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    640              OS_CPU_SR  cpu_sr = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    641          #endif
    642          
    643          
    644          
    645          #if OS_ARG_CHK_EN > 0
    646              if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
    647                  return (0);
    648              }
    649              if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
    650                  if (prio != OS_PRIO_SELF) {
    651                      *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
    652                      return (0);
    653                  }
    654              }
    655              if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
    656                  *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
    657                  return (0);
    658              }
    659          #endif
    660              if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
   \   0000000A   0x....             LDR.N    R0,??DataTable10_5
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSTaskNameGet_0
    661                  *perr = OS_ERR_NAME_GET_ISR;
   \   00000012   0x2011             MOVS     R0,#+17
   \   00000014   0x7020             STRB     R0,[R4, #+0]
    662                  return (0);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE02C             B.N      ??OSTaskNameGet_1
    663              }
    664              OS_ENTER_CRITICAL();
   \                     ??OSTaskNameGet_0: (+1)
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x0006             MOVS     R6,R0
    665              if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
   \   00000020   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000022   0x2FFF             CMP      R7,#+255
   \   00000024   0xD103             BNE.N    ??OSTaskNameGet_2
    666                  prio = OSTCBCur->OSTCBPrio;
   \   00000026   0x....             LDR.N    R0,??DataTable10_1
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF890 0x7032      LDRB     R7,[R0, #+50]
    667              }
    668              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskNameGet_2: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable10
   \   00000030   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000032   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
    669              if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD106             BNE.N    ??OSTaskNameGet_3
    670                  OS_EXIT_CRITICAL();                              /* No                                         */
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x.... 0x....      BL       OS_CPU_SR_Restore
    671                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   00000040   0x2043             MOVS     R0,#+67
   \   00000042   0x7020             STRB     R0,[R4, #+0]
    672                  return (0);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE015             B.N      ??OSTaskNameGet_1
    673              }
    674              if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
   \                     ??OSTaskNameGet_3: (+1)
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD106             BNE.N    ??OSTaskNameGet_4
    675                  OS_EXIT_CRITICAL();                              /* Yes                                        */
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0x.... 0x....      BL       OS_CPU_SR_Restore
    676                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   00000052   0x2043             MOVS     R0,#+67
   \   00000054   0x7020             STRB     R0,[R4, #+0]
    677                  return (0);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE00C             B.N      ??OSTaskNameGet_1
    678              }
    679              len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
   \                     ??OSTaskNameGet_4: (+1)
   \   0000005A   0xF110 0x014C      ADDS     R1,R0,#+76
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       OS_StrCopy
   \   00000064   0x0005             MOVS     R5,R0
    680              OS_EXIT_CRITICAL();
   \   00000066   0x0030             MOVS     R0,R6
   \   00000068   0x.... 0x....      BL       OS_CPU_SR_Restore
    681              *perr = OS_ERR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x7020             STRB     R0,[R4, #+0]
    682              return (len);
   \   00000070   0x0028             MOVS     R0,R5
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTaskNameGet_1: (+1)
   \   00000074   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    683          }
    684          #endif
    685          
    686          /*$PAGE*/
    687          /*
    688          *********************************************************************************************************
    689          *                                        ASSIGN A NAME TO A TASK
    690          *
    691          * Description: This function is used to set the name of a task.
    692          *
    693          * Arguments  : prio      is the priority of the task that you want the assign a name to.
    694          *
    695          *              pname     is a pointer to an ASCII string that contains the name of the task.  The ASCII
    696          *                        string must be NUL terminated.
    697          *
    698          *              perr       is a pointer to an error code that can contain one of the following values:
    699          *
    700          *                        OS_ERR_NONE                if the requested task is resumed
    701          *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
    702          *                        OS_ERR_TASK_NAME_TOO_LONG  if the name you are giving to the task exceeds the
    703          *                                                   storage capacity of a task name as specified by
    704          *                                                   OS_TASK_NAME_SIZE.
    705          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    706          *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
    707          *                                                   A higher value than the idle task or not OS_PRIO_SELF.
    708          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    709          *
    710          * Returns    : None
    711          *********************************************************************************************************
    712          */
    713          #if OS_TASK_NAME_SIZE > 1

   \                                 In section .text, align 2, keep-with-next
    714          void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
    715          {
   \                     OSTaskNameSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0014             MOVS     R4,R2
    716              INT8U      len;
    717              OS_TCB    *ptcb;
    718          #if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    719              OS_CPU_SR  cpu_sr = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    720          #endif
    721          
    722          
    723          
    724          #if OS_ARG_CHK_EN > 0
    725              if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
    726                  return;
    727              }
    728              if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
    729                  if (prio != OS_PRIO_SELF) {
    730                      *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
    731                      return;
    732                  }
    733              }
    734              if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
    735                  *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
    736                  return;
    737              }
    738          #endif
    739              if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
   \   0000000A   0x....             LDR.N    R0,??DataTable10_5
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD002             BEQ.N    ??OSTaskNameSet_0
    740                  *perr = OS_ERR_NAME_SET_ISR;
   \   00000012   0x2012             MOVS     R0,#+18
   \   00000014   0x7020             STRB     R0,[R4, #+0]
    741                  return;
   \   00000016   0xE033             B.N      ??OSTaskNameSet_1
    742              }
    743              OS_ENTER_CRITICAL();
   \                     ??OSTaskNameSet_0: (+1)
   \   00000018   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001C   0x0006             MOVS     R6,R0
    744              if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0x2FFF             CMP      R7,#+255
   \   00000022   0xD103             BNE.N    ??OSTaskNameSet_2
    745                  prio = OSTCBCur->OSTCBPrio;
   \   00000024   0x....             LDR.N    R0,??DataTable10_1
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF890 0x7032      LDRB     R7,[R0, #+50]
    746              }
    747              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskNameSet_2: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable10
   \   0000002E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000030   0xF850 0x7027      LDR      R7,[R0, R7, LSL #+2]
    748              if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
   \   00000034   0x2F00             CMP      R7,#+0
   \   00000036   0xD105             BNE.N    ??OSTaskNameSet_3
    749                  OS_EXIT_CRITICAL();                          /* No                                             */
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Restore
    750                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   0000003E   0x2043             MOVS     R0,#+67
   \   00000040   0x7020             STRB     R0,[R4, #+0]
    751                  return;
   \   00000042   0xE01D             B.N      ??OSTaskNameSet_1
    752              }
    753              if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
   \                     ??OSTaskNameSet_3: (+1)
   \   00000044   0x2F01             CMP      R7,#+1
   \   00000046   0xD105             BNE.N    ??OSTaskNameSet_4
    754                  OS_EXIT_CRITICAL();                          /* Yes                                            */
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    755                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   0000004E   0x2043             MOVS     R0,#+67
   \   00000050   0x7020             STRB     R0,[R4, #+0]
    756                  return;
   \   00000052   0xE015             B.N      ??OSTaskNameSet_1
    757              }
    758              len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
   \                     ??OSTaskNameSet_4: (+1)
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       OS_StrLen
    759              if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0x2810             CMP      R0,#+16
   \   0000005E   0xDB05             BLT.N    ??OSTaskNameSet_5
    760                  OS_EXIT_CRITICAL();
   \   00000060   0x0030             MOVS     R0,R6
   \   00000062   0x.... 0x....      BL       OS_CPU_SR_Restore
    761                  *perr = OS_ERR_TASK_NAME_TOO_LONG;
   \   00000066   0x2041             MOVS     R0,#+65
   \   00000068   0x7020             STRB     R0,[R4, #+0]
    762                  return;
   \   0000006A   0xE009             B.N      ??OSTaskNameSet_1
    763              }
    764              (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
   \                     ??OSTaskNameSet_5: (+1)
   \   0000006C   0x0029             MOVS     R1,R5
   \   0000006E   0xF117 0x004C      ADDS     R0,R7,#+76
   \   00000072   0x.... 0x....      BL       OS_StrCopy
    765              OS_EXIT_CRITICAL();
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0x.... 0x....      BL       OS_CPU_SR_Restore
    766              *perr = OS_ERR_NONE;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x7020             STRB     R0,[R4, #+0]
    767          }
   \                     ??OSTaskNameSet_1: (+1)
   \   00000080   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    768          #endif
    769          
    770          /*$PAGE*/
    771          /*
    772          *********************************************************************************************************
    773          *                                        RESUME A SUSPENDED TASK
    774          *
    775          * Description: This function is called to resume a previously suspended task.  This is the only call that
    776          *              will remove an explicit task suspension.
    777          *
    778          * Arguments  : prio     is the priority of the task to resume.
    779          *
    780          * Returns    : OS_ERR_NONE                if the requested task is resumed
    781          *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
    782          *                                         (i.e. >= OS_LOWEST_PRIO)
    783          *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
    784          *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
    785          *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
    786          *********************************************************************************************************
    787          */
    788          
    789          #if OS_TASK_SUSPEND_EN > 0

   \                                 In section .text, align 2, keep-with-next
    790          INT8U  OSTaskResume (INT8U prio)
    791          {
   \                     OSTaskResume: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    792              OS_TCB    *ptcb;
    793          #if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    794              OS_CPU_SR  cpu_sr = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    795          #endif
    796          
    797          
    798          
    799          #if OS_ARG_CHK_EN > 0
    800              if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
    801                  return (OS_ERR_PRIO_INVALID);
    802              }
    803          #endif
    804              OS_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
    805              ptcb = OSTCBPrioTbl[prio];
   \   0000000A   0x....             LDR.N    R1,??DataTable10
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
    806              if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD103             BNE.N    ??OSTaskResume_0
    807                  OS_EXIT_CRITICAL();
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Restore
    808                  return (OS_ERR_TASK_RESUME_PRIO);
   \   0000001A   0x2046             MOVS     R0,#+70
   \   0000001C   0xE03B             B.N      ??OSTaskResume_1
    809              }
    810              if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
   \                     ??OSTaskResume_0: (+1)
   \   0000001E   0x2901             CMP      R1,#+1
   \   00000020   0xD103             BNE.N    ??OSTaskResume_2
    811                  OS_EXIT_CRITICAL();
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Restore
    812                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000026   0x2043             MOVS     R0,#+67
   \   00000028   0xE035             B.N      ??OSTaskResume_1
    813              }
    814              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
   \                     ??OSTaskResume_2: (+1)
   \   0000002A   0xF891 0x2030      LDRB     R2,[R1, #+48]
   \   0000002E   0x0712             LSLS     R2,R2,#+28
   \   00000030   0xD52E             BPL.N    ??OSTaskResume_3
    815                  ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
   \   00000032   0xF891 0x2030      LDRB     R2,[R1, #+48]
   \   00000036   0xF012 0x02F7      ANDS     R2,R2,#0xF7
   \   0000003A   0xF881 0x2030      STRB     R2,[R1, #+48]
    816                  if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
   \   0000003E   0xF891 0x2030      LDRB     R2,[R1, #+48]
   \   00000042   0x2A00             CMP      R2,#+0
   \   00000044   0xD120             BNE.N    ??OSTaskResume_4
    817                      if (ptcb->OSTCBDly == 0) {
   \   00000046   0x8DCA             LDRH     R2,[R1, #+46]
   \   00000048   0x2A00             CMP      R2,#+0
   \   0000004A   0xD11A             BNE.N    ??OSTaskResume_5
    818                          OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
   \   0000004C   0x....             LDR.N    R2,??DataTable10_3
   \   0000004E   0x7812             LDRB     R2,[R2, #+0]
   \   00000050   0xF891 0x3036      LDRB     R3,[R1, #+54]
   \   00000054   0x431A             ORRS     R2,R3,R2
   \   00000056   0x....             LDR.N    R3,??DataTable10_3
   \   00000058   0x701A             STRB     R2,[R3, #+0]
    819                          OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   0000005A   0x....             LDR.N    R2,??DataTable10_2
   \   0000005C   0xF891 0x3034      LDRB     R3,[R1, #+52]
   \   00000060   0x5C9A             LDRB     R2,[R3, R2]
   \   00000062   0xF891 0x3035      LDRB     R3,[R1, #+53]
   \   00000066   0x431A             ORRS     R2,R3,R2
   \   00000068   0x....             LDR.N    R3,??DataTable10_2
   \   0000006A   0xF891 0x1034      LDRB     R1,[R1, #+52]
   \   0000006E   0x54CA             STRB     R2,[R1, R3]
    820                          OS_EXIT_CRITICAL();
   \   00000070   0x.... 0x....      BL       OS_CPU_SR_Restore
    821                          if (OSRunning == OS_TRUE) {
   \   00000074   0x....             LDR.N    R0,??DataTable10_4
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xD107             BNE.N    ??OSTaskResume_6
    822                              OS_Sched();                               /* Find new highest priority task        */
   \   0000007C   0x.... 0x....      BL       OS_Sched
   \   00000080   0xE004             B.N      ??OSTaskResume_6
    823                          }
    824                      } else {
    825                          OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_5: (+1)
   \   00000082   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000086   0xE001             B.N      ??OSTaskResume_6
    826                      }
    827                  } else {                                              /* Must be pending on event              */
    828                      OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_4: (+1)
   \   00000088   0x.... 0x....      BL       OS_CPU_SR_Restore
    829                  }
    830                  return (OS_ERR_NONE);
   \                     ??OSTaskResume_6: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE002             B.N      ??OSTaskResume_1
    831              }
    832              OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_3: (+1)
   \   00000090   0x.... 0x....      BL       OS_CPU_SR_Restore
    833              return (OS_ERR_TASK_NOT_SUSPENDED);
   \   00000094   0x2044             MOVS     R0,#+68
   \                     ??OSTaskResume_1: (+1)
   \   00000096   0xBD10             POP      {R4,PC}          ;; return
    834          }
    835          #endif
    836          /*$PAGE*/
    837          /*
    838          *********************************************************************************************************
    839          *                                             STACK CHECKING
    840          *
    841          * Description: This function is called to check the amount of free memory left on the specified task's
    842          *              stack.
    843          *
    844          * Arguments  : prio          is the task priority
    845          *
    846          *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
    847          *
    848          * Returns    : OS_ERR_NONE            upon success
    849          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
    850          *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    851          *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
    852          *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
    853          *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
    854          *********************************************************************************************************
    855          */
    856          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)

   \                                 In section .text, align 2, keep-with-next
    857          INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
    858          {
   \                     OSTaskStkChk: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    859              OS_TCB    *ptcb;
    860              OS_STK    *pchk;
    861              INT32U     nfree;
    862              INT32U     size;
    863          #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    864              OS_CPU_SR  cpu_sr = 0;
   \   00000006   0x2000             MOVS     R0,#+0
    865          #endif
    866          
    867          
    868          
    869          #if OS_ARG_CHK_EN > 0
    870              if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
    871                  if (prio != OS_PRIO_SELF) {
    872                      return (OS_ERR_PRIO_INVALID);
    873                  }
    874              }
    875              if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
    876                  return (OS_ERR_PDATA_NULL);
    877              }
    878          #endif
    879              p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6020             STR      R0,[R4, #+0]
    880              p_stk_data->OSUsed = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6060             STR      R0,[R4, #+4]
    881              OS_ENTER_CRITICAL();
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
    882              if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2DFF             CMP      R5,#+255
   \   00000018   0xD103             BNE.N    ??OSTaskStkChk_0
    883                  prio = OSTCBCur->OSTCBPrio;
   \   0000001A   0x....             LDR.N    R1,??DataTable10_1
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0xF891 0x5032      LDRB     R5,[R1, #+50]
    884              }
    885              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskStkChk_0: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable10
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
    886              if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD103             BNE.N    ??OSTaskStkChk_1
    887                  OS_EXIT_CRITICAL();
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Restore
    888                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000032   0x2043             MOVS     R0,#+67
   \   00000034   0xE01E             B.N      ??OSTaskStkChk_2
    889              }
    890              if (ptcb == OS_TCB_RESERVED) {
   \                     ??OSTaskStkChk_1: (+1)
   \   00000036   0x2901             CMP      R1,#+1
   \   00000038   0xD103             BNE.N    ??OSTaskStkChk_3
    891                  OS_EXIT_CRITICAL();
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Restore
    892                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000003E   0x2043             MOVS     R0,#+67
   \   00000040   0xE018             B.N      ??OSTaskStkChk_2
    893              }
    894              if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
   \                     ??OSTaskStkChk_3: (+1)
   \   00000042   0x7C0A             LDRB     R2,[R1, #+16]
   \   00000044   0x07D2             LSLS     R2,R2,#+31
   \   00000046   0xD403             BMI.N    ??OSTaskStkChk_4
    895                  OS_EXIT_CRITICAL();
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    896                  return (OS_ERR_TASK_OPT);
   \   0000004C   0x2045             MOVS     R0,#+69
   \   0000004E   0xE011             B.N      ??OSTaskStkChk_2
    897              }
    898              nfree = 0;
   \                     ??OSTaskStkChk_4: (+1)
   \   00000050   0x2600             MOVS     R6,#+0
    899              size  = ptcb->OSTCBStkSize;
   \   00000052   0x68CF             LDR      R7,[R1, #+12]
    900              pchk  = ptcb->OSTCBStkBottom;
   \   00000054   0x688D             LDR      R5,[R1, #+8]
    901              OS_EXIT_CRITICAL();
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   0000005A   0xE000             B.N      ??OSTaskStkChk_5
    902          #if OS_STK_GROWTH == 1
    903              while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
    904                  nfree++;
   \                     ??OSTaskStkChk_6: (+1)
   \   0000005C   0x1C76             ADDS     R6,R6,#+1
    905              }
   \                     ??OSTaskStkChk_5: (+1)
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x1D05             ADDS     R5,R0,#+4
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD0F9             BEQ.N    ??OSTaskStkChk_6
    906          #else
    907              while (*pchk-- == (OS_STK)0) {
    908                  nfree++;
    909              }
    910          #endif
    911              p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
   \   00000068   0x00B0             LSLS     R0,R6,#+2
   \   0000006A   0x6020             STR      R0,[R4, #+0]
    912              p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
   \   0000006C   0x1BB8             SUBS     R0,R7,R6
   \   0000006E   0x0080             LSLS     R0,R0,#+2
   \   00000070   0x6060             STR      R0,[R4, #+4]
    913              return (OS_ERR_NONE);
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??OSTaskStkChk_2: (+1)
   \   00000074   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    914          }
    915          #endif
    916          /*$PAGE*/
    917          /*
    918          *********************************************************************************************************
    919          *                                            SUSPEND A TASK
    920          *
    921          * Description: This function is called to suspend a task.  The task can be the calling task if the
    922          *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
    923          *
    924          * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
    925          *                       calling task will suspend itself and rescheduling will occur.
    926          *
    927          * Returns    : OS_ERR_NONE               if the requested task is suspended
    928          *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
    929          *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
    930          *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    931          *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
    932          *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
    933          *
    934          * Note       : You should use this function with great care.  If you suspend a task that is waiting for
    935          *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
    936          *              running when the event arrives.
    937          *********************************************************************************************************
    938          */
    939          
    940          #if OS_TASK_SUSPEND_EN > 0

   \                                 In section .text, align 2, keep-with-next
    941          INT8U  OSTaskSuspend (INT8U prio)
    942          {
   \                     OSTaskSuspend: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    943              BOOLEAN    self;
    944              OS_TCB    *ptcb;
    945              INT8U      y;
    946          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    947              OS_CPU_SR  cpu_sr = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    948          #endif
    949          
    950          
    951          
    952          #if OS_ARG_CHK_EN > 0
    953              if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
    954                  return (OS_ERR_TASK_SUSPEND_IDLE);
    955              }
    956              if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
    957                  if (prio != OS_PRIO_SELF) {
    958                      return (OS_ERR_PRIO_INVALID);
    959                  }
    960              }
    961          #endif
    962              OS_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
    963              if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x2DFF             CMP      R5,#+255
   \   0000000E   0xD105             BNE.N    ??OSTaskSuspend_0
    964                  prio = OSTCBCur->OSTCBPrio;
   \   00000010   0x....             LDR.N    R1,??DataTable10_1
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0xF891 0x5032      LDRB     R5,[R1, #+50]
    965                  self = OS_TRUE;
   \   00000018   0x2401             MOVS     R4,#+1
   \   0000001A   0xE009             B.N      ??OSTaskSuspend_1
    966              } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
   \                     ??OSTaskSuspend_0: (+1)
   \   0000001C   0x....             LDR.N    R1,??DataTable10_1
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0xF891 0x1032      LDRB     R1,[R1, #+50]
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x428D             CMP      R5,R1
   \   00000028   0xD101             BNE.N    ??OSTaskSuspend_2
    967                  self = OS_TRUE;
   \   0000002A   0x2401             MOVS     R4,#+1
   \   0000002C   0xE000             B.N      ??OSTaskSuspend_1
    968              } else {
    969                  self = OS_FALSE;                                        /* No suspending another task          */
   \                     ??OSTaskSuspend_2: (+1)
   \   0000002E   0x2400             MOVS     R4,#+0
    970              }
    971              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskSuspend_1: (+1)
   \   00000030   0x....             LDR.N    R1,??DataTable10
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
    972              if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD103             BNE.N    ??OSTaskSuspend_3
    973                  OS_EXIT_CRITICAL();
   \   0000003C   0x.... 0x....      BL       OS_CPU_SR_Restore
    974                  return (OS_ERR_TASK_SUSPEND_PRIO);
   \   00000040   0x2048             MOVS     R0,#+72
   \   00000042   0xE02A             B.N      ??OSTaskSuspend_4
    975              }
    976              if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
   \                     ??OSTaskSuspend_3: (+1)
   \   00000044   0x2901             CMP      R1,#+1
   \   00000046   0xD103             BNE.N    ??OSTaskSuspend_5
    977                  OS_EXIT_CRITICAL();
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    978                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000004C   0x2043             MOVS     R0,#+67
   \   0000004E   0xE024             B.N      ??OSTaskSuspend_4
    979              }
    980              y            = ptcb->OSTCBY;
   \                     ??OSTaskSuspend_5: (+1)
   \   00000050   0xF891 0x2034      LDRB     R2,[R1, #+52]
    981              OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
   \   00000054   0x....             LDR.N    R3,??DataTable10_2
   \   00000056   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000058   0x5CD3             LDRB     R3,[R2, R3]
   \   0000005A   0xF891 0x5035      LDRB     R5,[R1, #+53]
   \   0000005E   0x43AB             BICS     R3,R3,R5
   \   00000060   0x....             LDR.N    R5,??DataTable10_2
   \   00000062   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000064   0x5553             STRB     R3,[R2, R5]
    982              if (OSRdyTbl[y] == 0) {
   \   00000066   0x....             LDR.N    R3,??DataTable10_2
   \   00000068   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006A   0x5CD2             LDRB     R2,[R2, R3]
   \   0000006C   0x2A00             CMP      R2,#+0
   \   0000006E   0xD106             BNE.N    ??OSTaskSuspend_6
    983                  OSRdyGrp &= ~ptcb->OSTCBBitY;
   \   00000070   0x....             LDR.N    R2,??DataTable10_3
   \   00000072   0x7812             LDRB     R2,[R2, #+0]
   \   00000074   0xF891 0x3036      LDRB     R3,[R1, #+54]
   \   00000078   0x439A             BICS     R2,R2,R3
   \   0000007A   0x....             LDR.N    R3,??DataTable10_3
   \   0000007C   0x701A             STRB     R2,[R3, #+0]
    984              }
    985              ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
   \                     ??OSTaskSuspend_6: (+1)
   \   0000007E   0xF891 0x2030      LDRB     R2,[R1, #+48]
   \   00000082   0xF052 0x0208      ORRS     R2,R2,#0x8
   \   00000086   0xF881 0x2030      STRB     R2,[R1, #+48]
    986              OS_EXIT_CRITICAL();
   \   0000008A   0x.... 0x....      BL       OS_CPU_SR_Restore
    987              if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2C01             CMP      R4,#+1
   \   00000092   0xD101             BNE.N    ??OSTaskSuspend_7
    988                  OS_Sched();                                             /* Find new highest priority task      */
   \   00000094   0x.... 0x....      BL       OS_Sched
    989              }
    990              return (OS_ERR_NONE);
   \                     ??OSTaskSuspend_7: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \                     ??OSTaskSuspend_4: (+1)
   \   0000009A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    991          }
    992          #endif
    993          /*$PAGE*/
    994          /*
    995          *********************************************************************************************************
    996          *                                            QUERY A TASK
    997          *
    998          * Description: This function is called to obtain a copy of the desired task's TCB.
    999          *
   1000          * Arguments  : prio         is the priority of the task to obtain information from.
   1001          *
   1002          *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
   1003          *
   1004          * Returns    : OS_ERR_NONE            if the requested task is suspended
   1005          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
   1006          *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
   1007          *              OS_ERR_PRIO            if the desired task has not been created
   1008          *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
   1009          *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
   1010          *********************************************************************************************************
   1011          */
   1012          
   1013          #if OS_TASK_QUERY_EN > 0

   \                                 In section .text, align 2, keep-with-next
   1014          INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
   1015          {
   \                     OSTaskQuery: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1016              OS_TCB    *ptcb;
   1017          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1018              OS_CPU_SR  cpu_sr = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1019          #endif
   1020          
   1021          
   1022          
   1023          #if OS_ARG_CHK_EN > 0
   1024              if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
   1025                  if (prio != OS_PRIO_SELF) {
   1026                      return (OS_ERR_PRIO_INVALID);
   1027                  }
   1028              }
   1029              if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
   1030                  return (OS_ERR_PDATA_NULL);
   1031              }
   1032          #endif
   1033              OS_ENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000C   0x0006             MOVS     R6,R0
   1034              if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2CFF             CMP      R4,#+255
   \   00000012   0xD103             BNE.N    ??OSTaskQuery_0
   1035                  prio = OSTCBCur->OSTCBPrio;
   \   00000014   0x....             LDR.N    R0,??DataTable10_1
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF890 0x4032      LDRB     R4,[R0, #+50]
   1036              }
   1037              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskQuery_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable10
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   1038              if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD104             BNE.N    ??OSTaskQuery_1
   1039                  OS_EXIT_CRITICAL();
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0x.... 0x....      BL       OS_CPU_SR_Restore
   1040                  return (OS_ERR_PRIO);
   \   0000002E   0x2029             MOVS     R0,#+41
   \   00000030   0xE00E             B.N      ??OSTaskQuery_2
   1041              }
   1042              if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
   \                     ??OSTaskQuery_1: (+1)
   \   00000032   0x2901             CMP      R1,#+1
   \   00000034   0xD104             BNE.N    ??OSTaskQuery_3
   1043                  OS_EXIT_CRITICAL();
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Restore
   1044                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000003C   0x2043             MOVS     R0,#+67
   \   0000003E   0xE007             B.N      ??OSTaskQuery_2
   1045              }
   1046                                                           /* Copy TCB into user storage area                    */
   1047              OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
   \                     ??OSTaskQuery_3: (+1)
   \   00000040   0x225C             MOVS     R2,#+92
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0x.... 0x....      BL       OS_MemCopy
   1048              OS_EXIT_CRITICAL();
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
   1049              return (OS_ERR_NONE);
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??OSTaskQuery_2: (+1)
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
   1050          }
   1051          #endif
   1052          /*$PAGE*/
   1053          /*
   1054          *********************************************************************************************************
   1055          *                                        CLEAR TASK STACK
   1056          *
   1057          * Description: This function is used to clear the stack of a task (i.e. write all zeros)
   1058          *
   1059          * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
   1060          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
   1061          *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
   1062          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
   1063          *                       highest memory location of the stack and the stack will grow with increasing
   1064          *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
   1065          *
   1066          *              size     is the number of 'stack elements' to clear.
   1067          *
   1068          *              opt      contains additional information (or options) about the behavior of the task.  The
   1069          *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
   1070          *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
   1071          *
   1072          * Returns    : none
   1073          *********************************************************************************************************
   1074          */
   1075          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)

   \                                 In section .text, align 2, keep-with-next
   1076          void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
   1077          {
   1078              if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
   \                     OS_TaskStkClr: (+1)
   \   00000000   0x07D3             LSLS     R3,R2,#+31
   \   00000002   0xD508             BPL.N    ??OS_TaskStkClr_0
   1079                  if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
   \   00000004   0x0792             LSLS     R2,R2,#+30
   \   00000006   0xD404             BMI.N    ??OS_TaskStkClr_1
   \   00000008   0xE005             B.N      ??OS_TaskStkClr_0
   1080          #if OS_STK_GROWTH == 1
   1081                      while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
   1082                          size--;
   \                     ??OS_TaskStkClr_2: (+1)
   \   0000000A   0x1E49             SUBS     R1,R1,#+1
   1083                          *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x6002             STR      R2,[R0, #+0]
   \   00000010   0x1D00             ADDS     R0,R0,#+4
   1084                      }
   \                     ??OS_TaskStkClr_1: (+1)
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD1F9             BNE.N    ??OS_TaskStkClr_2
   1085          #else
   1086                      while (size > 0) {                         /* Stack grows from LOW to HIGH memory          */
   1087                          size--;
   1088                          *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
   1089                      }
   1090          #endif
   1091                  }
   1092              }
   1093          }
   \                     ??OS_TaskStkClr_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     OSTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     OSTCBList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     OSTCBFreeList
   1094          
   1095          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   OSTaskChangePrio
        40   -> OS_CPU_SR_Restore
        40   -> OS_CPU_SR_Save
        40   -> OS_Sched
      32   OSTaskCreate
        32   -> OSTaskStkInit
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> OS_Sched
        32   -> OS_TCBInit
      48   OSTaskCreateExt
        48   -> OSTaskStkInit
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
        48   -> OS_Sched
        48   -> OS_TCBInit
        48   -> OS_TaskStkClr
      16   OSTaskDel
        16   -> OSTaskDelHook
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_Dummy
        16   -> OS_EventTaskRemove
        16   -> OS_EventTaskRemoveMulti
        16   -> OS_FlagUnlink
        16   -> OS_Sched
       8   OSTaskDelReq
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
      24   OSTaskNameGet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
      24   OSTaskNameSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
        24   -> OS_StrLen
      16   OSTaskQuery
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_MemCopy
       8   OSTaskResume
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> OS_Sched
      24   OSTaskStkChk
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      16   OSTaskSuspend
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_Sched
       0   OS_TaskStkClr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
     494  OSTaskChangePrio
     160  OSTaskCreate
     192  OSTaskCreateExt
     382  OSTaskDel
      94  OSTaskDelReq
     118  OSTaskNameGet
     130  OSTaskNameSet
      82  OSTaskQuery
     152  OSTaskResume
     118  OSTaskStkChk
     156  OSTaskSuspend
      24  OS_TaskStkClr

 
 2 142 bytes in section .text
 
 2 142 bytes of CODE memory

Errors: none
Warnings: none
